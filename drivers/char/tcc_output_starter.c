/****************************************************************************
FileName    : kernel/drivers/char/tcc_output_starter.c
Description : 

Copyright (C) 2013 Telechips Inc.

This program is free software; you can redistribute it and/or modify it under the terms
of the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
Suite 330, Boston, MA 02111-1307 USA
****************************************************************************/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/fs.h>
#include <linux/miscdevice.h>
#include <linux/errno.h>
#include <linux/wait.h>
#include <linux/poll.h>
#include <linux/i2c.h>
#include <linux/clk.h>
#include <linux/i2c/hdmi_phy.h>
#include <linux/syscalls.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/delay.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <linux/clk-provider.h>


#include <asm/io.h>
#include <asm/mach-types.h>
#include <asm/uaccess.h>
#include <asm/gpio.h>
#include <asm/delay.h>

#include <soc/tcc/pmap.h>
#if defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
#include <mach/bsp.h>
#include <mach/gpio.h>
#include <mach/vioc_disp.h>
#include <mach/vioc_outcfg.h>
#include <mach/vioc_wmix.h>
#include <mach/vioc_rdma.h>
#include <mach/vioc_scaler.h>
#include <mach/vioc_global.h>
#include <mach/vioc_config.h>
#include <mach/tccfb_ioctrl.h>
#include <mach/tcc_fb.h>
#include <mach/tccfb.h>
#include <mach/tcc_composite_ioctl.h>
#include <mach/tcc_component_ioctl.h>
#include <mach/tcc_scaler_ctrl.h>
#include <mach/daudio_info.h>
#else
#include <video/tcc/gpio.h>
#include <video/tcc/tcc_types.h>
#include <video/tcc/vioc_disp.h>
#include <video/tcc/vioc_outcfg.h>
#include <video/tcc/vioc_wmix.h>
#include <video/tcc/vioc_rdma.h>
#include <video/tcc/vioc_scaler.h>
#include <video/tcc/vioc_global.h>
#include <video/tcc/vioc_config.h>
#include <video/tcc/tccfb_ioctrl.h>
#include <video/tcc/tcc_fb.h>
#include <video/tcc/tccfb.h>
#include <video/tcc/tcc_composite_ioctl.h>
#include <video/tcc/tcc_component_ioctl.h>
#include <video/tcc/tcc_scaler_ctrl.h>
#endif

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3)
#include "hdmi_v1_3/hdmi/regs-hdmi.h"
#include <mach/hdmi_1_3_audio.h>
#include <mach/hdmi_1_3_video.h>
#include <mach/hdmi_1_3_hdmi.h>
#elif defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
#include "hdmi_v1_4/hdmi/regs-hdmi.h"
#include <mach/hdmi_1_4_audio.h>
#include <mach/hdmi_1_4_video.h>
#include <mach/hdmi_1_4_hdmi.h>
#endif

#include "../video/fbdev/tcc-fb/vioc/tcc_component.h"
#include "../video/fbdev/tcc-fb/vioc/tcc_composite.h"
#include "../video/fbdev/tcc-fb/vioc/tcc_composite_internal.h"

/* Debugging stuff */
static int debug = 0;
#define DPRINTF(msg...)	if (debug) { printk( "tcc_output_starter: " msg); }

#define GPIO_OUTPUT_HDMI_DETECT		TCC_GPHDMI(1)
#define GPIO_OUTPUT_COMPOSITE_DETECT	TCC_GPF(1)
#define GPIO_OUTPUT_COMPONENT_DETECT	TCC_GPB(29)

#if defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
#define HDMI_1280X720_60P

#if defined(HDMI_720X480_60P)
#define HDMI_VIDEO_MODE_VIC     2
#define HDMI_VIDEO_MODE_HZ      60000
#endif


#if defined(HDMI_1280X720_60P)
#define HDMI_VIDEO_MODE_VIC     4
#define HDMI_VIDEO_MODE_HZ      60000
#endif

#if defined(HDMI_1920X1080_30P)
#define HDMI_VIDEO_MODE_VIC     34
#define HDMI_VIDEO_MODE_HZ      30000
#endif


#if defined(HDMI_1920X1080_60I)
#define HDMI_VIDEO_MODE_VIC     5
#define HDMI_VIDEO_MODE_HZ      60000
#endif

#if defined(HDMI_1920X1080_59P)
#define HDMI_VIDEO_MODE_VIC     16
#define HDMI_VIDEO_MODE_HZ      59940
#endif

#if defined(HDMI_1920X1080_60P)
#define HDMI_VIDEO_MODE_VIC     16
#define HDMI_VIDEO_MODE_HZ      60000
#endif


#if defined(HDMI_3840X2160_30P)
#define HDMI_VIDEO_MODE_VIC     95
#define HDMI_VIDEO_MODE_HZ      30000
#endif


#if defined(HDMI_3840X2160_59P)
#define HDMI_VIDEO_MODE_VIC     97
#define HDMI_VIDEO_MODE_HZ      59940
#endif


#if defined(HDMI_3840X2160_60P)
#define HDMI_VIDEO_MODE_VIC     97
#define HDMI_VIDEO_MODE_HZ      60000
#endif


#define HDMI_IMG_WIDTH  1280
#define HDMI_IMG_HEIGHT 720
#define HDMI_IMG_FMT            TCC_LCDC_IMG_FMT_RGB565

#endif

extern void tccfb_output_starter(char output_type, char lcdc_num, stLTIMING *pstTiming, stLCDCTR *pstCtrl, unsigned int swapbf);

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
extern void tcc_hdmi_power_on(void);
extern void hdmi_phy_reset(void);
extern int hdmi_set_color_space(enum ColorSpace);
extern int hdmi_set_color_depth(enum ColorDepth);
extern int hdmi_set_pixel_limit(enum PixelLimit);
extern int hdmi_set_hdmimode(int mode);
extern int hdmi_set_pixel_aspect_ratio(enum PixelAspectRatio ratio);
extern void hdmi_start(void);
#endif

extern void tcc_composite_get_spec(COMPOSITE_MODE_TYPE mode, COMPOSITE_SPEC_TYPE *spec);
extern void tcc_composite_attach(char lcdc_num, char mode, char starter_flag);
extern void tcc_component_get_spec(COMPONENT_MODE_TYPE mode, COMPONENT_SPEC_TYPE *spec);
extern void ths8200_enable(int mode, int starter_flag);

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
extern int hdmi_set_video_mode(struct HDMIVideoParameter* pVideo);
#elif defined(CONFIG_TCC_HDMI_DRIVER_V1_3)
extern void hdmi_set_video_mode(struct device_video_params mode);
#endif

static struct display_platform_data tcc_display_data;

extern struct HDMIVideoParameter gHdmiVideoParms;

extern char* boot_recovery_mode;

static inline u8 output_starter_readb (unsigned offset){
    return readb(IOMEM(offset));
}
static inline void output_starter_writeb(u8 b, unsigned offset){
    writeb(b, IOMEM(offset));
}
static inline u32 output_starter_readl(unsigned offset){
    return readl(IOMEM(offset));
}
static inline void output_starter_writel(u32 b, unsigned offset){
    writel(b, IOMEM(offset));
}

#if defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
int tcc_output_starter_hdmi_v2_0(unsigned int vic, unsigned int hz, unsigned int isdvi,
                                        unsigned int display_device,
                                        VIOC_RDMA *pRDMA, VIOC_SC *pSC, VIOC_WMIX *pWMIX, VIOC_DISP *pDISP, 
                                        unsigned int scaler_num, unsigned int image_width, unsigned int image_height, unsigned int image_fmt);
#endif

#if defined(CONFIG_TCC_DISPLAY_HDMI_LVDS)
void tccfb_output_starter_set_attach(int start);
#endif


#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
//! Structure for video timing parameters
static const struct hdmi_video_params
{
    /** [H Blank] */
    unsigned int    HBlank;

    /** [V Blank] */
    unsigned int    VBlank;

    /**
     * [H Total : V Total] @n
     * For more information, refer HDMI register map.
     */
    unsigned int    HVLine;

    /**
     * [H Sync polarity : H Sync end point : H Sync start point]@n
     * For more information, refer HDMI register map.
     */
    unsigned int    HSYNCGEN;

    /**
     * [V Sync start line num + V Sync end line num] @n
     * For more information, refer HDMI register map.
     */
    unsigned int    VSYNCGEN;

    /** CEA VIC */
    unsigned char   AVI_VIC;
    /** CEA VIC for 16:9 pixel ratio */
    unsigned char   AVI_VIC_16_9;

    /** 0 - progresive, 1 - interlaced */
    unsigned char   interlaced;

    /** Pixel repetition if double, set 1 */
    unsigned char   repetition;

    /** V Sync polarity */
    unsigned char   polarity;

    /**
     * In case of interlaced mode, @n
     * [end point of bottom field's active region : start point of that]@n
     * For more information, refer HDMI register map.
     */
    unsigned int    VBLANK_F;

    /**
     * In case of interlaced mode, @n
     * [start line of bottom field's V Sync : end line of that]@n
     * For more information, refer HDMI register map.
     */
    unsigned int    VSYNCGEN2;

    /**
     * In case of interlaced mode, @n
     * [start transition point of bottom field's V Sync : end transition of that]@n
     * For more information, refer HDMI register map.
     */
    unsigned int    VSYNCGEN3;

    /** Pixel frequency */
    enum PixelFreq PixelClock; // pixel clock
} HDMIVideoParams[] =
{

  //{ 0x140, 0x13326, 0x540326, 0x1070A0, 0x2008 , 1 , 1 , 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_65, },  // v1024x768p_60Hz
  //{ 0x140, 0x13326, 0x540326, 0x1701C , 0x3009 , 1 , 1 , 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_65, },  // v1024x768p_60Hz
    { 0xA0 , 0x16A0D, 0x32020D, 0x11B80E, 0xA00C , 1 , 1 , 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_25_200,  },  // v640x480p_60Hz
    { 0x8A , 0x16A0D, 0x35A20D, 0x11300E, 0x900F , 2 , 3 , 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_27_027,  },  // v720x480p_60Hz
    //MVC_PROCESS
	#if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
    { 0x172, 0xF2EE , 0x6722EE, 0x2506C , 0x500A , 4 , 4 , 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1280x720p_60Hz_3D
    #endif
    { 0x172, 0xF2EE , 0x6722EE, 0x2506C , 0x500A , 4 , 4 , 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1280x720p_60Hz
    { 0x118, 0xB232 , 0x898465, 0x20856 , 0x2007 , 5 , 5 , 1, 0, 0, 0x232A49, 0x234239, 0x4A44A4, PIXEL_FREQ_74_250,  },  // v1920x1080i_60Hz
    { 0x114, 0xB106 , 0x6B420D, 0x128024, 0x4007 , 6 , 7 , 1, 1, 1, 0x10691D, 0x10A10D, 0x380380, PIXEL_FREQ_27_027,  },  // v720x480i_60Hz
    { 0x114, 0xB106 , 0x6B4106, 0x128024, 0x4007 , 8 , 9 , 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_27_027,  },  // v720x240p_60Hz
    { 0x228, 0xB106 , 0xD6820D, 0x15084A, 0x4007 , 10, 11, 1, 1, 1, 0x10691D, 0x10A10D, 0x700700, PIXEL_FREQ_54_054,  },  // v2880x480i_60Hz
    { 0x228, 0xB106 , 0x6B4106, 0x15084A, 0x4007 , 12, 13, 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_54_054,  },  // v2880x240p_60Hz
    { 0x114, 0x16A0D, 0x6B420D, 0x12681E, 0x900F , 14, 15, 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_54_054,  },  // v1440x480p_60Hz
    { 0x118, 0x16C65, 0x898465, 0x20856 , 0x4009 , 16, 16, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_148_500, },  // v1920x1080p_60Hz
    { 0x90 , 0x18A71, 0x360271, 0x11280A, 0x500A , 17, 18, 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_27,      },  // v720x576p_50Hz
    { 0x2BC, 0xF2EE , 0x7BC2EE, 0x779B6 , 0x500A , 19, 19, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1280x720p_50Hz
    { 0x2D0, 0xB232 , 0xA50465, 0x8EA0E , 0x2007 , 20, 20, 1, 0, 0, 0x232A49, 0x234239, 0x738738, PIXEL_FREQ_74_250,  },  // v1920x1080i_50Hz
    { 0x120, 0xC138 , 0x6C0271, 0x125016, 0x2005 , 21, 22, 1, 1, 1, 0x138951, 0x13A13D, 0x378378, PIXEL_FREQ_27,      },  // v720x576i_50Hz
    { 0x120, 0xC138 , 0x6C0138, 0x125016, 0x3006 , 23, 24, 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_27,      },  // v720x288p_50Hz
    { 0x240, 0xC138 , 0xD80271, 0x14A82E, 0x2005 , 25, 26, 1, 1, 1, 0x138951, 0x13A13D, 0x6F06F0, PIXEL_FREQ_54,      },  // v2880x576i_50Hz
    { 0x240, 0xC138 , 0xD80138, 0x14A82E, 0x2005 , 27, 28, 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_54,      },  // v2880x288p_50Hz
    { 0x120, 0x18A71, 0x6C0271, 0x125816, 0x500A , 29, 30, 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_54,      },  // v1440x576p_50Hz
    { 0x2D0, 0x16C65, 0xA50465, 0x8EA0E , 0x4009 , 31, 31, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_148_500, },  // v1920x1080p_50Hz
    //MVC_PROCESS
    #if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
    { 0x33E, 0x16C65, 0xABE465, 0xAA27C , 0x4009 , 32, 32, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1920x1080p_24Hz_3D
    #endif
    { 0x33E, 0x16C65, 0xABE465, 0xAA27C , 0x4009 , 32, 32, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1920x1080p_24Hz
    { 0x2D0, 0x16C65, 0xA50465, 0x8EA0E , 0x4009 , 33, 33, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1920x1080p_25Hz
    { 0x2D0, 0x16C65, 0xA50465, 0x8EA0E , 0x4009 , 34, 34, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_74_250,  },  // v1920x1080p_30Hz
    { 0x228, 0x16A0D, 0xD6820D, 0x14D83E, 0x900F , 35, 36, 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_108_108, },  // v2880x480p_60Hz
    { 0x240, 0x18A71, 0xD80271, 0x14B82E, 0x500A , 37, 38, 0, 1, 1, 0       , 0       , 0       , PIXEL_FREQ_108,     },  // v2880x576p_50Hz
    { 0x180, 0x2AA71, 0x9004E2, 0x3181E , 0x1701C, 39, 39, 0, 0, 0, 0x2712C6, 0x28728F, 0x4a44a4, PIXEL_FREQ_72,      },  // v1920x1080i_50Hz(1250)
    { 0x2D0, 0xB232 , 0xA50465, 0x8EA0E , 0x2007 , 40, 40, 1, 0, 0, 0x232A49, 0x234239, 0x738738, PIXEL_FREQ_148_500, },  // v1920x1080i_100Hz
    { 0x2BC, 0xF2EE , 0x7BC2EE, 0x779B6 , 0x500A , 41, 41, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_148_500, },  // v1280x720p_100Hz
    { 0x90 , 0x18A71, 0x360271, 0x11280A, 0x500A , 42, 43, 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_54,      },  // v720x576p_100Hz
    { 0x120, 0xC138 , 0x6C0271, 0x125016, 0x2005 , 44, 45, 1, 1, 1, 0x138951, 0x13A13D, 0x378378, PIXEL_FREQ_54,      },  // v720x576i_100Hz
    { 0x118, 0xB232 , 0x898465, 0x20856 , 0x2007 , 46, 46, 1, 0, 0, 0x232A49, 0x234239, 0x4A44A4, PIXEL_FREQ_148_500, },  // v1920x1080i_120Hz
    { 0x172, 0xF2EE , 0x6722EE, 0x2506C , 0x500A , 47, 47, 0, 0, 0, 0       , 0       , 0       , PIXEL_FREQ_148_500, },  // v1280x720p_120Hz
    { 0x8A , 0x16A0D, 0x35A20D, 0x11300E, 0x900F , 48, 49, 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_54_054,  },  // v720x480p_120Hz
    { 0x114, 0xB106 , 0x6B420D, 0x128024, 0x4007 , 50, 51, 1, 1, 1, 0x10691D, 0x10A10D, 0x380380, PIXEL_FREQ_54_054,  },  // v720x480i_120Hz
    { 0x90 , 0x18A71, 0x360271, 0x11280A, 0x500A , 52, 53, 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_108,     },  // v720x576p_200Hz
    { 0x120, 0xC138 , 0x6C0271, 0x125016, 0x2005 , 54, 55, 1, 1, 1, 0x138951, 0x13A13D, 0x378378, PIXEL_FREQ_108,     },  // v720x576i_200Hz
    { 0x8A , 0x16A0D, 0x35A20D, 0x11300E, 0x900F , 56, 57, 0, 0, 1, 0       , 0       , 0       , PIXEL_FREQ_108_108, },  // v720x480p_240Hz
    { 0x114, 0xB106 , 0x6B420D, 0x128024, 0x4007 , 58, 59, 1, 1, 1, 0x10691D, 0x10A10D, 0x380380, PIXEL_FREQ_108_108, },  // v720x480i_240Hz
};

#if defined(CONFIG_ARCH_TCC893X)
// TCC8930 HDMI PHY Setting
static const unsigned char phy_config[][3][31] =
{
        //25.200
    {
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x10, 0x02, 0x51, 0x5F, 0xF1, 0x51, 0x7F, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x10, 0x02, 0x51, 0x9F, 0xF6, 0x51, 0x9E, 0x84, 0x00, 0x32, 0x38, 0x00, 0xB8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xC2, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x10, 0x02, 0x51, 0xFF, 0xF3, 0x51, 0xBD, 0x84, 0x00, 0x30, 0x38, 0x00, 0xA4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA2, 0x26, 0x00, 0x00, 0x00, 0x80},

    },
        //25.175
    {
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x1E, 0x20, 0x61, 0x50, 0x10, 0x51, 0xFF, 0xF1, 0x51, 0xBD, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x2B, 0x40, 0x61, 0x50, 0x10, 0x51, 0x7F, 0xF2, 0x51, 0xEC, 0x84, 0x00, 0x10, 0x38, 0x00, 0xB8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xC2, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x1E, 0x20, 0x61, 0x10, 0x02, 0x51, 0xFF, 0xF1, 0x51, 0xBD, 0x84, 0x00, 0x10, 0x38, 0x00, 0xA4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA2, 0x26, 0x00, 0x00, 0x00, 0x80},

    },
        //27.000
    {
		{0x05, 0x00, 0x10, 0x10, 0x9C, 0x01, 0xDB, 0x61, 0x10, 0x02, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE3, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9E, 0x2D, 0xDB, 0x61, 0x10, 0x02, 0x51, 0xEF, 0xF1, 0x51, 0xA9, 0x84, 0x00, 0x10, 0x38, 0x00, 0xB8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xB5, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9E, 0xD2, 0x5B, 0x61, 0x10, 0x02, 0x51, 0x2F, 0xF2, 0x51, 0xCB, 0x84, 0x00, 0x10, 0x38, 0x00, 0xA4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x00, 0x00, 0x00, 0x80},
    },
        //27.027
    {
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0x09, 0x64, 0x61, 0x10, 0x02, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE2, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0x31, 0x50, 0x61, 0x10, 0x02, 0x51, 0x8F, 0xF3, 0x51, 0xA9, 0x84, 0x00, 0x30, 0x38, 0x00, 0xB8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xB5, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0x10, 0x10, 0x9C, 0x1B, 0x64, 0x61, 0x10, 0x02, 0x51, 0x7F, 0xF8, 0x51, 0xCB, 0x84, 0x00, 0x32, 0x38, 0x00, 0xA4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x00, 0x00, 0x00, 0x80},
    },
        //54.000
    {
		{0x05, 0x00, 0x10, 0x10, 0x9C, 0x01, 0xDB, 0x61, 0x10, 0x01, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE3, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x2D, 0xDB, 0x61, 0x10, 0x01, 0x51, 0xCF, 0xF1, 0x51, 0xA9, 0x84, 0x00, 0x10, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xB5, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xD2, 0x5B, 0x61, 0x10, 0x01, 0x51, 0x2F, 0xF2, 0x51, 0xCB, 0x84, 0x00, 0x10, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x01, 0x00, 0x00, 0x80},
    },
        //54.054
    {
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0x09, 0x64, 0x61, 0x10, 0x01, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE2, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0x31, 0x50, 0x61, 0x10, 0x01, 0x51, 0x8F, 0xF3, 0x51, 0xA9, 0x84, 0x00, 0x30, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xB5, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0x10, 0x10, 0x9C, 0x1B, 0x64, 0x61, 0x10, 0x01, 0x51, 0x7F, 0xF8, 0x51, 0xCB, 0x84, 0x00, 0x32, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x01, 0x00, 0x00, 0x80},
    },
        //74.250
    {
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xE9, 0xDC, 0x61, 0x10, 0x01, 0x51, 0xFF, 0xF1, 0x51, 0xBA, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA4, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x37, 0xD0, 0x61, 0x10, 0x01, 0x51, 0xDF, 0xF4, 0x51, 0xE8, 0x84, 0x00, 0x30, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x83, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xE2, 0xD0, 0x61, 0x10, 0x01, 0x51, 0xDF, 0xF5, 0x51, 0x16, 0x85, 0x00, 0x30, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xDC, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //74.176
    {
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0xBC, 0xDB, 0x61, 0x10, 0x01, 0x51, 0xEF, 0xF3, 0x51, 0xB9, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA5, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0xAB, 0xDB, 0x61, 0x10, 0x01, 0x51, 0xBF, 0xF9, 0x51, 0xE8, 0x84, 0x00, 0x32, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x84, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xCD, 0xDB, 0x61, 0x10, 0x01, 0x51, 0xDF, 0xF5, 0x51, 0x16, 0x84, 0x00, 0x30, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xDC, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //148.500
    {
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xE9, 0xDC, 0x61, 0x18, 0x00, 0x51, 0xFF, 0xF1, 0x51, 0xBA, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA4, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x37, 0xD0, 0x61, 0x18, 0x00, 0x51, 0xDF, 0xF4, 0x51, 0xE8, 0x84, 0x00, 0x30, 0x38, 0x00, 0xF8, 0x10, 0x60, /*0x22, 0x40,*/ 0x08,0x42, 0x83, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xE2, 0xD0, 0x61, 0x18, 0x00, 0x51, 0xDF, 0xF5, 0x51, 0x16, 0x85, 0x00, 0x30, 0x38, 0x00, 0xE4, 0x10, 0x60, /*0x22, 0x40,*/ 0x08,0x42, 0x6D, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //148.352
    {
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0xBC, 0xDB, 0x61, 0x18, 0x00, 0x51, 0xEF, 0xF3, 0x51, 0xB9, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA5, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0xAB, 0xDB, 0x61, 0x18, 0x00, 0x51, 0xBF, 0xF9, 0x51, 0xE8, 0x84, 0x00, 0x32, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x08,0x42, 0x84, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xCD, 0xDB, 0x61, 0x18, 0x00, 0x51, 0xDF, 0xF5, 0x51, 0x16, 0x85, 0x00, 0x30, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x08,0x42, 0x6D, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //108.108
    {
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0x09, 0x64, 0x61, 0x18, 0x00, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE2, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD4, 0x10, 0x9C, 0x31, 0x50, 0x61, 0x18, 0x00, 0x51, 0x8F, 0xF3, 0x51, 0xA9, 0x84, 0x00, 0x30, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xB5, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0x10, 0x10, 0x9C, 0x1B, 0x64, 0x61, 0x18, 0x00, 0x51, 0x7F, 0xF8, 0x51, 0xCB, 0x84, 0x00, 0x32, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //72.000
    {
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x10, 0x01, 0x51, 0xEF, 0xF1, 0x51, 0xB4, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xAA, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x10, 0x01, 0x51, 0xBF, 0xF4, 0x51, 0xE1, 0x84, 0x00, 0x30, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x88, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x18, 0x00, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE3, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //25.000
    {
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x20, 0x40, 0x61, 0x50, 0x10, 0x51, 0xFF, 0xF1, 0x51, 0xBC, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xF5, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x08, 0x40, 0x61, 0x50, 0x10, 0x51, 0x7F, 0xF2, 0x51, 0xEA, 0x84, 0x00, 0x10, 0x38, 0x00, 0xB8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xC4, 0x26, 0x00, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x20, 0x40, 0x61, 0x10, 0x02, 0x51, 0xFF, 0xF1, 0x51, 0xBC, 0x84, 0x00, 0x10, 0x38, 0x00, 0xA4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xA3, 0x26, 0x00, 0x00, 0x00, 0x80},
    },
        //65.000
    {
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x02, 0x0C, 0x61, 0x10, 0x01, 0x51, 0xBF, 0xF1, 0x51, 0xA3, 0x84, 0x00, 0x10, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xBC, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xF2, 0x30, 0x61, 0x10, 0x01, 0x51, 0x1F, 0xF2, 0x51, 0xCB, 0x84, 0x00, 0x10, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x96, 0x26, 0x01, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xD0, 0x40, 0x61, 0x10, 0x01, 0x51, 0x9F, 0xF2, 0x51, 0xF4, 0x84, 0x00, 0x10, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x7D, 0x26, 0x01, 0x00, 0x00, 0x80},
    },
        //108.000
    {
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x18, 0x00, 0x51, 0xDF, 0xF2, 0x51, 0x87, 0x84, 0x00, 0x30, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xE3, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x02, 0x08, 0x61, 0x18, 0x00, 0x51, 0xCF, 0xF1, 0x51, 0xA9, 0x84, 0x00, 0x10, 0x38, 0x00, 0xF8, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0xB5, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xFC, 0x08, 0x61, 0x18, 0x00, 0x51, 0x2F, 0xF2, 0x51, 0xCB, 0x84, 0x00, 0x10, 0x38, 0x00, 0xE4, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x02, 0x00, 0x00, 0x80},
    },
        //162.000
    {
		{0x05, 0x00, 0xD8, 0x10, 0x1C, 0x30, 0x40, 0x61, 0x18, 0x00, 0x51, 0x7F, 0xF8, 0x51, 0xCB, 0x84, 0x00, 0x32, 0x38, 0x00, 0x08, 0x10, 0xE0, /*0x22, 0x40,*/ 0x00,0x40, 0x97, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0x18, 0x40, 0x61, 0x18, 0x00, 0x51, 0xAF, 0xF2, 0x51, 0xFD, 0x84, 0x00, 0x10, 0x38, 0x00, 0xF8, 0x10, 0x60, /*0x22, 0x40,*/ 0x08,0x42, 0x78, 0x26, 0x02, 0x00, 0x00, 0x80},
		{0x05, 0x00, 0xD8, 0x10, 0x9C, 0xD0, 0x40, 0x61, 0x18, 0x00, 0x51, 0x3F, 0xF3, 0x51, 0x30, 0x85, 0x00, 0x10, 0x38, 0x00, 0xE4, 0x10, 0x60, /*0x22, 0x40,*/ 0x08,0x42, 0x64, 0x26, 0x02, 0x00, 0x00, 0x80},
    }
};
#elif defined(CONFIG_ARCH_TCC896X) || defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
// TCC896X & TCC897X HDMI PHY Setting
static const unsigned char phy_config[][3][32] =
{
	//25.200Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x52,0x3F,0x55,0x40,0x01,0x00,0xC8,0x82,0xC8,0xBD,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x01,0x84,0x05,0x02,0x24,0x86,0x54,0xF4,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0x52,0x69,0x75,0x57,0x01,0x00,0xC8,0x82,0xC8,0x3B,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x01,0x84,0x05,0x02,0x24,0x86,0x54,0xC3,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0x52,0x3F,0x35,0x63,0x01,0x00,0xC8,0x82,0xC8,0xBD,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xA3,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//25.175Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x1F,0x50,0x40,0x20,0x1E,0xC8,0x81,0xE8,0xBD,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xF4,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x27,0x51,0x55,0x40,0x2B,0xC8,0x81,0xE8,0xEC,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xC3,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x1F,0x30,0x63,0x20,0x1E,0xC8,0x81,0xE8,0xBD,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xA3,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//27.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x22,0x51,0x40,0x08,0xFC,0xE0,0x98,0xE8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xE4,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2A,0x52,0x55,0x08,0x03,0xC8,0x86,0xE8,0xFD,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB6,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x33,0x54,0x65,0x08,0xFA,0xC8,0x85,0xE8,0x30,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x98,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//27.027Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x2D,0x72,0x40,0x64,0x12,0xC8,0x43,0xE8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xE3,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x38,0x74,0x57,0x50,0x31,0xC1,0x80,0xC8,0x52,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB6,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD4,0x87,0x31,0x63,0x64,0x1B,0xE0,0x19,0xE8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x98,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//54.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x51,0x2D,0x35,0x40,0x01,0x00,0xC8,0x82,0xC8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xE4,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x38,0x35,0x53,0x08,0x04,0xC8,0x88,0xE8,0x52,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB6,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x22,0x15,0x61,0x08,0xFC,0xC8,0x82,0xC8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x98,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//54.054Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x2D,0x32,0x40,0x64,0x12,0xC8,0x43,0xE8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xE3,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD2,0x70,0x34,0x53,0x50,0x31,0xC8,0x80,0xC8,0x52,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB6,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD4,0x87,0x11,0x61,0x64,0x1B,0xE0,0x19,0xE8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x98,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//74.250Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x1F,0x10,0x40,0x40,0xF8,0xC8,0x81,0xE8,0xBA,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xA5,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x27,0x11,0x51,0x40,0xD6,0xC8,0x81,0xE8,0xE8,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x84,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2E,0x12,0x61,0x40,0x34,0xC8,0x82,0xE8,0x16,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB9,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//74.176Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x1F,0x10,0x40,0x5B,0xEF,0xC8,0x81,0xE8,0xB9,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xA6,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x27,0x14,0x51,0x5B,0xA7,0xC8,0x84,0xE8,0xE8,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x85,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD2,0x5D,0x12,0x61,0x5B,0xCD,0xD0,0x43,0xE8,0x16,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xBA,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//148.500Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x1F,0x00,0x40,0x40,0xF8,0xC8,0x81,0xE8,0xBA,0xD8,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x4B,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x27,0x01,0x50,0x40,0xD6,0xC8,0x81,0xE8,0xE8,0xD8,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x09,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2E,0x02,0x60,0x40,0x34,0xC8,0x82,0xE8,0x16,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xDD,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//148.352Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x1F,0x00,0x40,0x5B,0xEF,0xC8,0x81,0xE8,0xB9,0xD8,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x4B,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x27,0x04,0x50,0x5B,0xA7,0xC8,0x84,0xE8,0xE8,0xD8,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x09,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD2,0x5D,0x02,0x60,0x5B,0xCD,0xD0,0x43,0xE8,0x16,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xDD,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//108.108Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x2D,0x12,0x40,0x64,0x12,0xC8,0x43,0xE8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xC7,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD2,0x70,0x14,0x51,0x50,0x31,0xC8,0x80,0xC8,0x52,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x6C,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD4,0x87,0x01,0x60,0x64,0x1B,0xE0,0x19,0xE8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x2F,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//72.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x51,0x1E,0x15,0x40,0x01,0x00,0xC8,0x82,0xC8,0xB4,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xAB,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0x52,0x4B,0x15,0x51,0x01,0x00,0xC8,0x82,0xC8,0xE1,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x89,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0x51,0x2D,0x15,0x61,0x01,0x00,0xC8,0x82,0xC8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xC7,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//25.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x2A,0x72,0x40,0x3C,0xD8,0xC8,0x86,0xE8,0xFA,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xF6,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x27,0x51,0x55,0x40,0x08,0xC8,0x81,0xE8,0xEA,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xC5,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x1F,0x30,0x63,0x40,0x20,0xC8,0x81,0xE8,0xBC,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xA4,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//65.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x36,0x34,0x40,0x0C,0x04,0xC8,0x82,0xE8,0x45,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xBD,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x22,0x11,0x51,0x30,0xF2,0xC8,0x86,0xE8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x97,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x29,0x12,0x61,0x40,0xD0,0xC8,0x87,0xE8,0xF4,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//108.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x51,0x2D,0x15,0x40,0x01,0x00,0xC8,0x82,0xC8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xC7,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x38,0x14,0x51,0x08,0x04,0xC8,0x80,0xC8,0x52,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x6C,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x22,0x01,0x60,0x08,0xFC,0xC8,0x86,0xE8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x2F,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//162.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x54,0x87,0x05,0x40,0x01,0x00,0xC8,0x82,0xC8,0xCB,0xD8,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x2F,0x25,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2A,0x02,0x50,0x40,0x18,0xC8,0x86,0xE8,0xFD,0xD8,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xF3,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x33,0x04,0x60,0x40,0xD0,0xC8,0x85,0xE8,0x30,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xCA,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//45.000Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x52,0x4B,0x35,0x40,0x01,0x00,0xC8,0x82,0xC8,0xE1,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x11,0x25,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2F,0x32,0x53,0x40,0xF0,0xC8,0x81,0xE8,0x19,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xDA,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x38,0x34,0x63,0x40,0x20,0xC8,0x80,0xC8,0x52,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB6,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//44.955Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x25,0x31,0x40,0x5B,0x54,0xC8,0x83,0xE8,0xE1,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x11,0x25,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD2,0x5D,0x32,0x53,0x5B,0x3B,0xD0,0x83,0xE8,0x19,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xDB,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD2,0x70,0x35,0x63,0x5B,0x23,0xC8,0x88,0xE8,0x51,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xB6,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//297.000Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x3E,0x05,0x40,0x40,0xE0,0xC8,0x42,0xE8,0x73,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xA5,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3E,0x05,0x40,0x40,0xE0,0xC8,0x42,0xE8,0x73,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xA5,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3E,0x05,0x40,0x40,0xE0,0xC8,0x42,0xE8,0x73,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xA5,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//296.703Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x3E,0x05,0x40,0x5B,0xDE,0xC8,0x82,0xE8,0x73,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xA6,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3E,0x05,0x40,0x5B,0xDE,0xC8,0x82,0xE8,0x73,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xA6,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3E,0x05,0x40,0x5B,0xDE,0xC8,0x82,0xE8,0x73,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0xA6,0x24,0x03,0x00,0x00,0x01,0x80,0x90},
	},
	
	//59.400Mhz
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x52,0x63,0x35,0x40,0x01,0x00,0xC8,0x82,0xC8,0x29,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xCF,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x1F,0x10,0x51,0x40,0xF8,0xC8,0x81,0xE8,0xBA,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xA5,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x25,0x11,0x61,0x40,0x10,0xC8,0x83,0xE8,0xDF,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x8A,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//36.000Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0x51,0x2D,0x55,0x40,0x40,0x00,0xC8,0x02,0xC8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xAB,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0x51,0x2D,0x55,0x40,0x40,0x00,0xC8,0x02,0xC8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xAB,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0x51,0x2D,0x55,0x40,0x40,0x00,0xC8,0x02,0xC8,0x0E,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0xAB,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//40.000Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x21,0x31,0x40,0x3C,0x28,0xC8,0x87,0xE8,0xC8,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x9A,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x21,0x31,0x40,0x3C,0x28,0xC8,0x87,0xE8,0xC8,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x9A,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x21,0x31,0x40,0x3C,0x28,0xC8,0x87,0xE8,0xC8,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x9A,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//71.000Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x3B,0x35,0x40,0x0C,0x04,0xC8,0x85,0xE8,0x63,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x57,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3B,0x35,0x40,0x0C,0x04,0xC8,0x85,0xE8,0x63,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x57,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3B,0x35,0x40,0x0C,0x04,0xC8,0x85,0xE8,0x63,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x57,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//83.500Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x23,0x11,0x40,0x0C,0xFB,0xC8,0x85,0xE8,0xD1,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x4A,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x23,0x11,0x40,0x0C,0xFB,0xC8,0x85,0xE8,0xD1,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x4A,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x23,0x11,0x40,0x0C,0xFB,0xC8,0x85,0xE8,0xD1,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x4A,0x24,0x00,0x00,0x00,0x01,0x80,0x90},
	},
	
	//106.500Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x2C,0x12,0x40,0x0C,0x09,0xC8,0x84,0xE8,0x0A,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x73,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2C,0x12,0x40,0x0C,0x09,0xC8,0x84,0xE8,0x0A,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x73,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x2C,0x12,0x40,0x0C,0x09,0xC8,0x84,0xE8,0x0A,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x73,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//122.500Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x33,0x14,0x40,0x0C,0x01,0xC8,0x85,0xE8,0x32,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x64,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x33,0x14,0x40,0x0C,0x01,0xC8,0x85,0xE8,0x32,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x64,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x33,0x14,0x40,0x0C,0x01,0xC8,0x85,0xE8,0x32,0xD9,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x64,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},
	
	//146.250Mhz
	//We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
	{
	   // TMDS Data Amplitude[4:0] : (Reg40 Bit<3:0>, REG3C Bit<7>), TMDS Clock Amplitude[3:0] : (Reg5C Bit<7:3>), TMDS Pre-emphasis Control : (Reg40 Bit<7:4>)
	   //0x04,0x08,0x0C,0x10,0x14.0x18,0x1C,0x20,0x24,0x28,0x2C,0x30,0x34,0x38,0x3C,0x40,0x44,0x48,0x4C,0x50,0x54,0x58,0x5C,0x60,0x64,0x68,0x6C,0x70,0x74,0x78,0x7C,0x80
		{0xD1,0x3D,0x15,0x40,0x18,0xFD,0xC8,0x83,0xE8,0x6E,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x54,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3D,0x15,0x40,0x18,0xFD,0xC8,0x83,0xE8,0x6E,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x54,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
		{0xD1,0x3D,0x15,0x40,0x18,0xFD,0xC8,0x83,0xE8,0x6E,0xD9,0x45,0xA0,0xAC,0x30,0x0e,0x80,0x09,0x84,0x05,0x02,0x24,0xe4,0x54,0x54,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	},

#if 0
        //97.34Mhz 
		//  change to lcdc clock        nPCLKCTRL.sel = PCLKCTRL_SEL_HDMITMDS;
       //We only support 8bit mode, 10bit and 12bit is same setting with 8bit. If you set 10bit and 12bit, there is no meaning.
    {
        {0xD1,0x29,0x12,0x61,0x40,0xD0,0xC8,0x87,0xE8,0xF4,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
        {0xD1,0x29,0x12,0x61,0x40,0xD0,0xC8,0x87,0xE8,0xF4,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
        {0xD1,0x29,0x12,0x61,0x40,0xD0,0xC8,0x87,0xE8,0xF4,0xD8,0x45,0xA0,0xAC,0x30,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
    }
#else
	{
	    {0xD1,0x29,0x12,0x40,0x3C,0xCB,0xC8,0x87,0xE8,0xF3,0xD8,0x45,0xA0,0xAC,0x80,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	    {0xD1,0x29,0x12,0x40,0x3C,0xCB,0xC8,0x87,0xE8,0xF3,0xD8,0x45,0xA0,0xAC,0x80,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},
	    {0xD1,0x29,0x12,0x40,0x3C,0xCB,0xC8,0x87,0xE8,0xF3,0xD8,0x45,0xA0,0xAC,0x80,0x08,0x80,0x09,0x84,0x05,0x02,0x24,0x86,0x54,0x7E,0x24,0x01,0x00,0x00,0x01,0x80,0x90},	        
	}
#endif//

};

#endif

#if (0)
#define DEFAULT_HDMI_LCDC_TIMING	{ 0,  1,  1,  0,  0,  1,  0,  1,  0,  61 ,    639 ,   59 ,     37 ,    0,  0,  5,  479 ,   29,  8,   5,   479 ,    29,  8, /*640x480p @ 60Hz       25.200MHz   */ }
#else
#define DEFAULT_HDMI_LCDC_TIMING	{ 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   147,     87 ,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 60Hz     148.5MHz    */ }
#endif

static const struct lcdc_timimg_parms_t LCDCTimimgParams[] = 
{                                                  /*  ID  IV  IH  IP  DP  NI  TV TFT STN  LPW       LPC   LSWC     LEWC   VDB VDF FPW    FLC  FSWC FEWC FPW2   FLC2  FSWC2 FEWC2 */
  /* v640x480p_60Hz         PIXEL_FREQ_25_200,  */    { 0,  1,  1,  0,  0,  1,  0,  1,  0,  61 ,    639 ,   59 ,     37 ,    0,  0,  5,  479 ,   29,  8,   5,   479 ,    29,  8, /*640x480p @ 60Hz       25.200MHz   */ },
  /* v720x480p_60Hz         PIXEL_FREQ_27_027,  */    { 0,  1,  1,  0,  0,  1,  0,  1,  0,  61 ,    719 ,   59 ,     15 ,    0,  0,  5,  479 ,   29,  8,   5,   479 ,    29,  8, /*720x480p @ 60Hz       27.027MHz   */ },
  //MVC_PROCESS
  #if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
  /* v1280x720p_60Hz_3D	  PIXEL_FREQ_148_500, */	{ 0,  0,  0,  0,  0,  1,  0,  1,  0,  39 ,	  1279,   219,	   109,    0,  0,  4,  1469 ,	19,  4,   4,   1469 ,	 19,  4, /*1280x720p @ 60Hz    148.5MHz, 3D Frame packing */ },
  #endif
  /* v1280x720p_60Hz        PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  39 ,    1279,   219,     109,    0,  0,  4,  719 ,   19,  4,   4,   719 ,    19,  4, /*1280x720p @ 60Hz      74.25MHz    */ },
  /* v1920x1080i_60Hz       PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  0,  1,  0,  0,  43 ,    1919,   147,     87 ,    0,  0,  9,  1079,   29,  3,   9,   1079,    31,  3, /*1920x1080i @ 60Hz     74.25MHz    */ },
  /* v720x480i_60Hz         PIXEL_FREQ_27_027,  */    { 0,  1,  1,  0,  1,  0,  1,  0,  0,  123,    1439,   113,     37 ,    0,  0,  5,  479 ,   29,  7,   5,   479 ,    31,  7, /*720x480i @ 60Hz       27.027MHz   */ },
  /* v720x240p_60Hz         PIXEL_FREQ_27_027,  */    DEFAULT_HDMI_LCDC_TIMING,
  /* v2880x480i_60Hz        PIXEL_FREQ_54_054,  */    DEFAULT_HDMI_LCDC_TIMING,
  /* v2880x240p_60Hz        PIXEL_FREQ_54_054,  */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1440x480p_60Hz        PIXEL_FREQ_54_054,  */    {0, 0, 0, 0, 1, 1, 0, 1, 0, 123, 1439, 120, 30, 0, 0, 5, 479, 32, 5, 5, 479, 32, 5, /*1440x480p @ 60Hz 54.054MHz*/ },
  /* v1920x1080p_60Hz       PIXEL_FREQ_148_500, */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   147,     87 ,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 60Hz     148.5MHz    */ },
  /* v720x576p_50Hz         PIXEL_FREQ_27,      */    { 0,  1,  1,  0,  0,  1,  0,  1,  0,  63 ,    719 ,   67 ,     11 ,    0,  0,  4,  575 ,   38,  4,   4,   575 ,    38,  4, /*720x576p @ 50Hz       27MHz       */ },
  /* v1280x720p_50Hz        PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  39 ,    1279,   219,     439,    0,  0,  4,  719 ,   19,  4,   4,   719 ,    19,  4, /*1280x720p @ 50Hz      74.25MHz    */ },
  /* v1920x1080i_50Hz       PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  0,  1,  0,  0,  43 ,    1919,   174,     500,    0,  0,  9,  1079,   29,  3,   9,   1079,    31,  3, /*1920x1080i @ 50Hz     74.25MHz    */ },
  /* v720x576i_50Hz         PIXEL_FREQ_27,      */    { 0,  1,  1,  0,  1,  0,  1,  0,  0,  125,    1439,   137,     23 ,    0,  0,  5,  575 ,   37,  3,   5,   575 ,    39,  3, /*720x576i @ 50Hz       27MHz       */ },
  /* v720x288p_50Hz         PIXEL_FREQ_27,      */    DEFAULT_HDMI_LCDC_TIMING,
  /* v2880x576i_50Hz        PIXEL_FREQ_54,      */    DEFAULT_HDMI_LCDC_TIMING,
  /* v2880x288p_50Hz        PIXEL_FREQ_54,      */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1440x576p_50Hz        PIXEL_FREQ_54,      */    {0, 0, 1, 0, 1, 1, 0, 1, 0, 125, 1439, 137, 23, 0, 0, 4, 575, 38, 4, 4, 575, 38, 4, /*1440x576p @ 50Hz 54MHz    */ },
  /* v1920x1080p_50Hz       PIXEL_FREQ_148_500, */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   174,     500,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 50Hz     148.5MHz    */ },
  /* v1920x1080p_23.976Hz   PIXEL_FREQ_74_176,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   500,     284,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 24Hz     74.176MHz    */ },
  //MVC_PROCESS
  #if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
  /* v1920x1080p_24Hz_3D	  PIXEL_FREQ_148_500, */	{ 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,	  1919,   500,	   284,    0,  0,  4,  2204,   35,	3,	 4,   2204,    35,	3, /*1920x1080p @ 24Hz	   74.25MHz    */ },
  #endif
  /* v1920x1080p_24Hz       PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   500,     284,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 24Hz     74.25MHz    */ },
  /* v1920x1080p_25Hz       PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   430,     244,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 25Hz     74.25MHz    */ },
  /* v1920x1080p_30Hz       PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   147,     87 ,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 30Hz     74.25MHz    */ },
  /* v2880x480p_60Hz        PIXEL_FREQ_108_108, */    DEFAULT_HDMI_LCDC_TIMING,
  /* v2880x576p_50Hz        PIXEL_FREQ_108,     */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1920x1080i_50Hz(1250) PIXEL_FREQ_72,      */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1920x1080i_100Hz      PIXEL_FREQ_148_500, */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1280x720p_100Hz       PIXEL_FREQ_148_500, */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x480p_120Hz        PIXEL_FREQ_54_054,  */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x480i_120Hz        PIXEL_FREQ_54_054,  */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x576p_200Hz        PIXEL_FREQ_108,     */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x576i_200Hz        PIXEL_FREQ_108,     */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x480p_240Hz        PIXEL_FREQ_108_108, */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x480i_240Hz        PIXEL_FREQ_108_108, */    DEFAULT_HDMI_LCDC_TIMING,

  /* v1280x720p24Hz         PHY_FREQ_59_400,    */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1280x720p25Hz         PHY_FREQ_74_250,    */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1280x720p30Hz         PHY_FREQ_74_250,    */    DEFAULT_HDMI_LCDC_TIMING,

#if 0
  /* v720x576p_100Hz        PIXEL_FREQ_54,      */    DEFAULT_HDMI_LCDC_TIMING,
  /* v720x576i_100Hz        PIXEL_FREQ_54,      */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1920x1080i_120Hz      PIXEL_FREQ_148_500, */    DEFAULT_HDMI_LCDC_TIMING,
  /* v1280x720p_120Hz       PIXEL_FREQ_148_500, */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  39 ,    1279,   219,     109,    0,  0,  4,  719 ,   19,  4,   4,   719 ,    19,  4, /*1280x720p @ 60Hz      74.25MHz    */ },
  #if 0 
  /* v1360x768p_60Hz        PIXEL_FREQ_84_75,   */    { 0,  0,  0,  0,  0,  1,  0,  1,  0, 111 ,   1359,    63,    255 ,    0,  0,  5,   767,   2,  17,   5,    767,    2,  17, /* 1360x768p @ 60Hz     84.75MHz    */ },
  #endif
  /* v1360x768p_60Hz        PIXEL_FREQ_84_75,   */    { 0,  0,  0,  0,  0,  1,  0,  1,  0, 135 ,   1359,    71,    207 ,    0,  0,  4,   767,   2,  21,   4,    767,    2,  21, /* 1360x768p @ 60Hz     84.75MHz    */ },
  /* v1366x768p_60Hz        PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  88 ,   1365,    43,     56 ,    0,  0,  5,   767,   2,  17,   5,    767,    2,  17, /* 1366x768p @ 60Hz     84.75MHz    */ },
  /* v1024x768p_60Hz        PIXEL_FREQ_65    ,  */    { 0,  1,  1,  0,  0,  1,  0,  1,  0,  135,   1023,   159,     23 ,    0,  0,  5,   767,  28,   2,   5,    767 ,  28,   2, /*1024x768p @ 60Hz     65.000MHz   */ },
  /*  v854x768p_60Hz        PIXEL_FREQ_37_293,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,   47,    853,   115,     85 ,    0,  0, 19,   479,  33,  28,  19,    479,   33,  28, /*  854x480p @ 60Hz     37.293MHz   */ },  
#endif
  /* v1920x1080p_30Hz       PIXEL_FREQ_74_250,  */    { 0,  0,  0,  0,  0,  1,  0,  1,  0,  43 ,    1919,   147,     87 ,    0,  0,  4,  1079,   35,  3,   4,   1079,    35,  3, /*1920x1080p @ 30Hz     74.25MHz    */ },

  /* v1920x720p_60Hz       PIXEL_FREQ_97_340, */    { 0,  0,  0,  0,   0,   1,   0,  1,  0,        19 ,    1919,   79,     59 ,    0,  0,  0,  719,   56,  1,   0,   719,    56,  1, /*1920x720p @ 60Hz     97.34MHz    */ },

};

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
//! Phy frequency according to video resoulution
static const enum PHYFreq PhyFreq[][3] =
{
	{ PHY_FREQ_25_200	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v640x480p_60Hz
	{ PHY_FREQ_27_027	, PHY_FREQ_54_054		, PHY_FREQ_108_108	, },	        // v720x480p_60Hz
	//MVC_PROCESS
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1280x720p_60Hz_3D
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1280x720p_60Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080i_60Hz
	{ PHY_FREQ_27_027	, PHY_FREQ_54_054		, PHY_FREQ_108_108	, },	        // v720x480i_60Hz
	{ PHY_FREQ_27_027	, PHY_FREQ_54_054		, PHY_FREQ_108_108	, },	        // v720x240p_60Hz
//	{ PHY_FREQ_27_027	, PHY_FREQ_54_054		, PHY_FREQ_108_108	, },	        // v720x240p_60Hz(mode 2)
	{ PHY_FREQ_54_054	, PHY_FREQ_108_108		, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x480i_60Hz
	{ PHY_FREQ_54_054	, PHY_FREQ_108_108		, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x240p_60Hz
//	{ PHY_FREQ_54_054	, PHY_FREQ_108_108		, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x240p_60Hz(mode 2)
	{ PHY_FREQ_54_054	, PHY_FREQ_108_108		, PHY_FREQ_NOT_SUPPORTED, },	    // v1440x480p_60Hz
	{ PHY_FREQ_148_500	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080p_60Hz
	{ PHY_FREQ_27		, PHY_FREQ_54	 		, PHY_FREQ_108 		, },	        // v720x576p_50Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1280x720p_50Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080i_50Hz
	{ PHY_FREQ_27		, PHY_FREQ_54	 		, PHY_FREQ_108 		, }, 	        // v720x576i_50Hz
	{ PHY_FREQ_27		, PHY_FREQ_54 			, PHY_FREQ_108 		, }, 	        // v720x288p_50Hz
//	{ PHY_FREQ_27		, PHY_FREQ_54 			, PHY_FREQ_108 		, }, 	        // v720x288p_50Hz(mode 2)
//	{ PHY_FREQ_27		, PHY_FREQ_54 			, PHY_FREQ_108 		, }, 	        // v720x288p_50Hz(mode 3)
	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x576i_50Hz
	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x288p_50Hz
//	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x288p_50Hz(mode 2)
//	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v2880x288p_50Hz(mode 3)
	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v1440x576p_50Hz
	{ PHY_FREQ_148_500	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080p_50Hz
	{ PHY_FREQ_74_176	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080p_23.976Hz
	//MVC_PROCESS
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080p_24Hz_3D
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080p_24Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080p_25Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080p_30Hz
	{ PHY_FREQ_108_108	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v2880x480p_60Hz
	{ PHY_FREQ_108		, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v2880x576p_50Hz
	{ PHY_FREQ_72		, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080i_50Hz(1250)
	{ PHY_FREQ_148_500	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080i_100Hz
	{ PHY_FREQ_148_500	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1280x720p_100Hz
	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v720x576p_100Hz
	{ PHY_FREQ_54		, PHY_FREQ_108 			, PHY_FREQ_NOT_SUPPORTED, },	    // v720x576i_100Hz
	{ PHY_FREQ_148_500	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080i_120Hz
	{ PHY_FREQ_148_500	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1280x720p_120Hz
	{ PHY_FREQ_54_054	, PHY_FREQ_108_108		, PHY_FREQ_NOT_SUPPORTED, },	    // v720x480p_120Hz
	{ PHY_FREQ_54_054	, PHY_FREQ_108_108		, PHY_FREQ_NOT_SUPPORTED, },	    // v720x480i_120Hz
	{ PHY_FREQ_108		, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v720x576p_200Hz
	{ PHY_FREQ_108		, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v720x576i_200Hz
	{ PHY_FREQ_108_108	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v720x480p_240Hz
	{ PHY_FREQ_108_108	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v720x480i_240Hz

	{ PHY_FREQ_59_400	, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1280x720p24Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1280x720p25Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1280x720p30Hz
//	{ PHY_FREQ_297		, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080p120Hz
//	{ PHY_FREQ_297		, PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },	// v1920x1080p100Hz
	{ PHY_FREQ_74_250	, PHY_FREQ_148_500		, PHY_FREQ_NOT_SUPPORTED, },	    // v1920x1080p_30Hz

       { PHY_FREQ_97_340       , PHY_FREQ_NOT_SUPPORTED, PHY_FREQ_NOT_SUPPORTED, },    // v1920x720p_60Hz


};
#endif

#define SUPPORT_HDMI_MODE_NUM	8
enum VideoFormat TccSupportHdmiMode[] = {
	/** 1920x1080p\@60Hz */
 	v1920x1080p_60Hz,
	/** 1920x1080p\@50Hz */
 	v1920x1080p_50Hz,
	/** 1920x1080i\@60Hz */
 	v1920x1080i_60Hz,
	/** 1920x1080i\@50Hz */
 	v1920x1080i_50Hz,
	/** 1280x700p\@60Hz */
	v1280x720p_60Hz,
	/** 1280x700p\@50Hz */
	v1280x720p_50Hz,
	/** 720x576p\@50Hz */
	v720x576p_50Hz,
	/** 720x480p\@60Hz */
	v720x480p_60Hz,
	/** 640x480p\@60Hz */
	v640x480p_60Hz,

	/** 1920x720p\@60Hz */
	v1920x720p_60Hz,	
};

#endif

enum
{
	STARTER_LCDC_0 = 0,
	STARTER_LCDC_1,
	STARTER_LCDC_MAX
};

enum
{
	STARTER_OUTPUT_LCD = 0,
	STARTER_OUTPUT_HDMI,
	STARTER_OUTPUT_COMPOSITE,
	STARTER_OUTPUT_COMPONENT,
	STARTER_OUTPUT_MAX
};

enum
{
	STARTER_HDMI_1920x1080P_60Hz = 0,
	STARTER_HDMI_1920x1080P_50Hz = 1,
	STARTER_HDMI_1920x1080I_60Hz = 2,
	STARTER_HDMI_1920x1080I_50Hz = 3,
	STARTER_HDMI_1280x720P_60Hz = 4,
	STARTER_HDMI_1280x720P_50Hz = 5,
	STARTER_HDMI_720x576P_50Hz = 6,
	STARTER_HDMI_720x480P_60Hz = 7,
	STARTER_HDMI_640x480P_60Hz = 8,
	STARTER_HDMI_1920x720P_60Hz = 9,	
	STARTER_HDMI_MAX
};

enum
{
	STARTER_COMPOSITE_NTSC = 0,
	STARTER_COMPOSITE_PAL,
	STARTER_COMPOSITE_MAX
};

enum
{
	STARTER_COMPONENT_480I_NTSC = 0,
	STARTER_COMPONENT_576I_PAL,
	STARTER_COMPONENT_720P,
	STARTER_COMPONENT_1080I,
	STARTER_COMPONENT_MAX
};

static char default_hdmi_resolution = STARTER_HDMI_1280x720P_60Hz;
static char default_composite_resolution = STARTER_COMPOSITE_NTSC;
#if defined(CONFIG_FB_TCC_COMPONENT_ADV7343) && defined(CONFIG_ARCH_TCC898X)
char default_component_resolution = STARTER_COMPONENT_1080I;
#else
char default_component_resolution = STARTER_COMPONENT_720P;
#endif
EXPORT_SYMBOL(default_component_resolution);

static int hdmi_hpd_port = 0;

#define PHY_I2C_ADDRESS				0x70>>1
#define PHY_REG_MODE_SET_DONE		0x28
#define PHY_CONFIG_START_OFFSET     0x01

static const struct i2c_device_id tcc_hdmi_phy_i2c_id[] = {
	{ "tcc-hdmi-phy", 0, },
	{ }
};

struct tcc_hdmi_i2c_chip_info {
	unsigned gpio_start;
	uint16_t reg_output;
	uint16_t reg_direction;

	struct i2c_client *client;
	struct gpio_chip gpio_chip;
};

static struct i2c_driver tcc_hdmi_phy_i2c_driver;

struct i2c_client *tcc_hdmi_phy_i2c_client = NULL;

static pmap_t pmap_fb;
static pmap_t pmap_attach;

static int						Output_Starter_LCDC_Num;
static PVIOC_DISP				pOutput_Starter_DISP;
static PVIOC_WMIX				pOutput_Starter_WMIX;
static PVIOC_RDMA				pOutput_Starter_RDMA;
static PVIOC_SC					pOutput_Starter_SCALER;
static PNTSCPAL					pOutput_Starter_TVE;
static PNTSCPAL_ENCODER_CTRL	pOutput_Starter_TVE_VEN;
static PDDICONFIG				pOutput_Starter_DDICFG;

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4) || defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
static int tcc_hdmi_detect_cable(void)
{
        int ret = true;

        #if defined(TCC_OUTPUT_STARTER_AUTO_HDMI_CVBS) || defined(TCC_OUTPUT_STARTER_ATTACH_DUAL_AUTO)
                ret = gpio_get_value(hdmi_hpd_port);
        #endif

        printk("tcc_hdmi_detect_cable = %d\r\n", ret);

        return ret;
}
#endif

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
static int tcc_hdmi_phy_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    struct device_node *np = client->dev.of_node;

	of_property_read_u32(np, "reg", (u32 *)&client->addr);

	DPRINTF("%s, addr=0x%02x\n", __func__, client->addr);

	tcc_hdmi_phy_i2c_client = client;

	return 0;
}

static int tcc_hdmi_phy_i2c_remove(struct i2c_client *client)
{
	DPRINTF("%s\n", __func__);
	
	tcc_hdmi_phy_i2c_client = NULL;

	return 0;
}

#ifdef CONFIG_OF
static const struct of_device_id tcc_hdmi_phy_of_match[] = {
	{.compatible = "telechips,tcc893x-hdmi-phy", },
	{ },
};
MODULE_DEVICE_TABLE(of, tcc_hdmi_phy_of_match);
#endif

static struct i2c_driver tcc_hdmi_phy_i2c_driver = {
	.probe		= tcc_hdmi_phy_i2c_probe,
	.remove		= tcc_hdmi_phy_i2c_remove,
	.id_table	= tcc_hdmi_phy_i2c_id,
	.driver = {
		.name	= "tcc-hdmi-phy",
        .owner	= THIS_MODULE,
#ifdef CONFIG_OF
        .of_match_table = tcc_hdmi_phy_of_match,
#endif
	},
};

int tcc_hdmi_phy_i2c_write(unsigned char reg, unsigned char *val, unsigned short len)
{
	unsigned char data[132];
	unsigned int cnt;
	unsigned char bytes;

	if (tcc_hdmi_phy_i2c_client == NULL)
		return ENODEV;

	data[0] = reg;
	bytes = 1;
	
	for(cnt = 0; cnt<len; cnt++)
	{
		data[bytes + cnt] = val[cnt];
	}

	bytes += len;

	if(i2c_master_send(tcc_hdmi_phy_i2c_client, data, bytes) != bytes)
	{
		printk("write error!!!! \n");
		return -EIO; 
	}
	
	return 0;
}

int tcc_hdmi_phy_i2c_read(unsigned char reg, unsigned char *val, unsigned short len)
{
	unsigned char bytes;
	
	if (tcc_hdmi_phy_i2c_client == NULL)
		return ENODEV;

	bytes = 1;
	if (i2c_master_send(tcc_hdmi_phy_i2c_client, &reg, bytes) != bytes)
	{
		printk("read(w) error!!!! \n");
		return -EIO;
	}

	bytes = len;
	if (i2c_master_recv(tcc_hdmi_phy_i2c_client, val, bytes) != bytes)
	{
		printk("read error!!!! \n");
		return -EIO;    
	}

	return 0;
}

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)

#if defined(CONFIG_ARCH_TCC896X) || defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
/**
 * Set Phy Freq.@n
 * @param   freq   [in] freq of phy
 * @return  If argument is invalid, return 0;Otherwise return 1.
 */
int hdmi_set_phy_freq(enum PHYFreq freq, unsigned int index)
{
    int size = 0;
    unsigned char *buffer;
	unsigned char reg = 0;
	int i = 0;

    size = sizeof(phy_config[freq][index]) /
      sizeof(phy_config[freq][index][0]);
    buffer = (unsigned char *) phy_config[freq][index];

	{
		DPRINTF("%s : freq = %d, phy_index = %d, size = %d",__func__,(int)freq, index, size);

		for(i=0; i<size; i++)
		{
			DPRINTF("0x%02x ", buffer[i]);
		}
		
		DPRINTF("\n");
	}

    // Clear Top:MODE_SET_DONE.
	// If you set the PHY setting, you must clear Mode_Set_Done.
    reg = 0x00;
	output_starter_writeb(reg, HDMIDP_PHYREG(0x7C));

	for(i=0;i<(size-1); i++)
	{
		output_starter_writeb(buffer[i], HDMIDP_PHYREG((i+1)*4));
	}

	output_starter_writeb(0x90, HDMIDP_PHYREG(0x8C));

	// Set Top:MODE_SET_DONE.
	//If you apply the PHY Setting, you must set MODE_SET_DONE>
	reg = 0x80;
	output_starter_writeb(reg, HDMIDP_PHYREG(0x7C));

	{
		for(i=0; i<size; i++)
		{
			buffer[i] = output_starter_readb( HDMIDP_PHYREG(i));
			DPRINTF("0x%02x ", buffer[i]);
		}
		
		DPRINTF("\n");
	}

	return 1;
}
static int tcc_hdmi_set_phy_pwdn(unsigned char enable)
{
	unsigned char reg = 0;

	if(enable) {
	    // Clear Top:MODE_SET_DONE.
		// If you set the PHY setting, you must clear Mode_Set_Done.
	    reg = 0x00;
		output_starter_writeb(reg, HDMIDP_PHYREG(0x7C));

		//TX Power down(Reg74) Bit<6:4>,Bit<2:0> : refer LN28LPP_HDMI_v1p4_TX_PHY_DataSheet_REV1.2.pdf 
		// Bit<6> : PLL PD(PLL & Bias Block Power Down)
		// Bit<5> : TX_CLKSER_PD (Clock Serializer Power Down)
		// Bit<4> : TX_CLKDRV_PD (TMDS Clock Driver Power Down)
		// Bit<2> : TX_DRV_PD (TMDS Data Driver Power Down)
		// Bit<1> : TX_SER_PD (TMDS Data Serializer Power Down)
		// Bit<0> : TX_CLK_PD (TMDS Internal Clock Buffer / Divider Power Down)

		reg = 0x36;
		output_starter_writeb(reg, HDMIDP_PHYREG(0x74));	

		// Set Top:MODE_SET_DONE.
		//If you apply the PHY Setting, you must set MODE_SET_DONE>
		reg = 0x80;
		output_starter_writeb(reg, HDMIDP_PHYREG(0x7C));

		reg = output_starter_readb( HDMIDP_PHYREG(0x74));
		printk("Reg74  = 0x%02x \n", reg);
	}

	return 1;
}


#endif


int tcc_hdmi_phy_config(const enum PHYFreq freq, const enum ColorDepth depth)
{
    int index;
#if defined(CONFIG_ARCH_TCC893X)
    int size;
    unsigned char *buffer;
    unsigned char reg;
#endif

    // get depth index
    switch (depth)
    {
        case HDMI_CD_24:
            index = 0;
            break;
        case HDMI_CD_30:
            index = 1;
            break;
        case HDMI_CD_36:
            index = 2;
            break;
        default:
            DPRINTF("not available depth arg = %d\n", (int)depth);
            return 0;
    }

#if defined(CONFIG_ARCH_TCC893X)

    // start to reconfig after that phy_ready goes down
    reg = 0x00;
	tcc_hdmi_phy_i2c_write(PHY_REG_MODE_SET_DONE, &reg, 1);

	reg = 0x00;
	tcc_hdmi_phy_i2c_write(PHY_CONFIG_START_OFFSET + 30 , &reg, 1);

    size = sizeof(phy_config[freq][index]) /
      sizeof(phy_config[freq][index][0]);
    buffer = (unsigned char *) phy_config[freq][index];

	tcc_hdmi_phy_i2c_write(PHY_CONFIG_START_OFFSET, buffer, (size - 1) );

	reg = 0x80;
	tcc_hdmi_phy_i2c_write(PHY_CONFIG_START_OFFSET + 30 , &reg, 1);

#elif defined(CONFIG_ARCH_TCC896X) || defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
	hdmi_set_phy_freq(freq, index);
#endif

    return 1;
}

int tcc_hdmi_set_phy_config(const struct HDMIVideoParameter * const hdmi_video_mode)
{
    unsigned char phy_ready = 0;
    int i = 0;

	DPRINTF("%s hdmi_video_mode->hdmi_3d_format = %d\n", __func__, hdmi_video_mode->hdmi_3d_format);

	phy_ready = output_starter_readb(HDMI_SS_PHY_STATUS_0);

    if (!phy_ready)
		hdmi_phy_reset();

	if ( hdmi_video_mode->hdmi_3d_format == HDMI_3D_FP_FORMAT ||
		hdmi_video_mode->hdmi_3d_format == HDMI_3D_SSF_FORMAT || 
		hdmi_video_mode->hdmi_3d_format == HDMI_3D_LD_FORMAT )
	// for doubled 
	{
		if (!tcc_hdmi_phy_config(PhyFreq[hdmi_video_mode->resolution][1],
		  hdmi_video_mode->colorDepth))
		{
			DPRINTF("phy config failed! [LINE = %d]\n", __LINE__);
			//return 0;
		}
	}
	else if ( hdmi_video_mode->hdmi_3d_format == HDMI_3D_LDGFX_FORMAT )
	// for 4 times
	{
		if (!tcc_hdmi_phy_config(PhyFreq[hdmi_video_mode->resolution][2],
		  hdmi_video_mode->colorDepth))
		{
			DPRINTF("phy config failed! [LINE = %d]\n", __LINE__);
			//return 0;
		}
	}
	else
	{
		if (!tcc_hdmi_phy_config(PhyFreq[hdmi_video_mode->resolution][0],
		  hdmi_video_mode->colorDepth))
    {
			DPRINTF("phy config failed! [LINE = %d]\n", __LINE__);
			//return 0;
		}
    }

	msleep(16);

    do {
		phy_ready = output_starter_readb(HDMI_SS_PHY_STATUS_0);
        if (i++ == 1000) break;
    } while (!phy_ready);

    if (!phy_ready)
    {
        DPRINTF("phy is not ready!!!\n");
    }
    else
    {
        DPRINTF("phy configured\n");
    }

    return 1;
}
#else
int tcc_hdmi_phy_config(const enum PixelFreq clk, const enum ColorDepth depth)
{
    int index, freq;
    int size;
    unsigned char *buffer;
    unsigned char reg;

	DPRINTF("%s\n", __func__);

    // get depth index
    switch (depth)
    {
        case HDMI_CD_24:
            index = 0;
            break;
        case HDMI_CD_30:
            index = 1;
            break;
        case HDMI_CD_36:
            index = 2;
            break;
        default:
            printk("not available depth arg = %d\n", (int)depth);
            return 0;
    }

    // get clk freq index
    switch (clk)
    {
        case PIXEL_FREQ_25_200 :
            freq = 0;
            break;
        case PIXEL_FREQ_25_175 :
            freq = 1;
            break;
        case PIXEL_FREQ_27 :
            freq = 2;
            break;
        case PIXEL_FREQ_27_027 :
            freq = 3;
            break;
        case PIXEL_FREQ_54 :
            freq = 4;
            break;
        case PIXEL_FREQ_54_054 :
            freq = 5;
            break;
        case PIXEL_FREQ_74_250 :
            freq = 6;
            break;
        case PIXEL_FREQ_74_176 :
            freq = 7;
            break;
        case PIXEL_FREQ_148_500 :
            freq = 8;
            break;
        case PIXEL_FREQ_148_352 :
            freq = 9;
            break;
        case PIXEL_FREQ_108_108 :
            freq = 10;
            break;
        case PIXEL_FREQ_72 :
            freq = 11;
            break;
        case PIXEL_FREQ_25 :
            freq = 12;
            break;
        case PIXEL_FREQ_65 :
            freq = 13;
            break;
        case PIXEL_FREQ_108 :
            freq = 14;
            break;
        case PIXEL_FREQ_162 :
            freq = 15;
            break;
        default:
            printk("not availlable clk arg = %d\n",(int)clk);
            return 0;
    }

    // start to reconfig after that phy_ready goes down
    reg = 0x00;

	tcc_hdmi_phy_i2c_write(PHY_REG_MODE_SET_DONE, &reg, 1);

	{volatile int ttt;for(ttt=0;ttt<500;ttt++);}

    size = sizeof(phy_config[freq][index]) / sizeof(phy_config[freq][index][0]);
    buffer = (unsigned char *) phy_config[freq][index];


	tcc_hdmi_phy_i2c_write(PHY_CONFIG_START_OFFSET, buffer, size);

    return 1;
}

int tcc_hdmi_set_phy_config(const struct HDMIVideoParameter * const hdmi_video_mode)
{
    unsigned char phy_ready = 0;
    int i = 0;

	DPRINTF("%s\n", __func__);

	phy_ready = output_starter_readb(HDMI_PHY_STATUS);

    if (!phy_ready)
		hdmi_phy_reset();

    if (!tcc_hdmi_phy_config(HDMIVideoParams[hdmi_video_mode->resolution].PixelClock, hdmi_video_mode->colorDepth))
    {
        DPRINTF("phy config failed!\n");
        return 0;
    }

    do {
		phy_ready = output_starter_readb(HDMI_PHY_STATUS);
        if (i++ == 1000) break;
    } while (!phy_ready);

    if (!phy_ready)
    {
        DPRINTF("phy is not ready!!!\n");
    }
    else
    {
        DPRINTF("phy configured\n");
    }

    return 1;
}
#endif

int tcc_hdmi_set_lcdc_config(char lcdc_num, enum VideoFormat hdmi_video_format)
{
	struct lcdc_timimg_parms_t device;
	stLTIMING stHDMI_Timing;
	stLCDCTR stHDMI_Ctrl;

	DPRINTF("%s, lcdc_num=%d\n", __func__, lcdc_num);

    memcpy((void*)&device,(const void*)&(LCDCTimimgParams[hdmi_video_format]),sizeof(device));

	memset(&stHDMI_Timing, 0x00, sizeof(stHDMI_Timing));
	stHDMI_Timing.lpw = device.lpw;
	stHDMI_Timing.lpc = device.lpc + 1;
	stHDMI_Timing.lswc = device.lswc + 1;
	stHDMI_Timing.lewc = device.lewc + 1;
	stHDMI_Timing.vdb = device.vdb;
	stHDMI_Timing.vdf = device.vdf;
	stHDMI_Timing.fpw = device.fpw;
	stHDMI_Timing.flc = device.flc;
	stHDMI_Timing.fswc = device.fswc;
	stHDMI_Timing.fewc = device.fewc;
	stHDMI_Timing.fpw2 = device.fpw2;
	stHDMI_Timing.flc2 = device.flc2;
	stHDMI_Timing.fswc2 = device.fswc2;
	stHDMI_Timing.fewc2 = device.fewc2;

	memset(&stHDMI_Ctrl, 0x00, sizeof(stHDMI_Ctrl));
	stHDMI_Ctrl.id = device.id;
	stHDMI_Ctrl.iv = device.iv;
	stHDMI_Ctrl.ih = device.ih;
	stHDMI_Ctrl.ip = device.ip;
	stHDMI_Ctrl.clen = 0;
	stHDMI_Ctrl.r2y = 0;
	stHDMI_Ctrl.dp = device.dp;
	stHDMI_Ctrl.ni = device.ni;
	#if defined(CONFIG_TCC_M2M_USE_INTERLACE_OUTPUT)
		if(device.ni == 0)
			stHDMI_Ctrl.advi = 0;
	#else
		if(device.ni == 0)
			stHDMI_Ctrl.advi = 1;
	#endif
	stHDMI_Ctrl.tv = device.tv;
	#if 0//defined(CONFIG_TCC_OUTPUT_COLOR_SPACE_YUV) : pjj delete please
		if(output_starter_state || hdmi_get_hdmimode() == DVI)
			CtrlParam.pxdw = 12; //RGB888
		else
			CtrlParam.pxdw = 8; //YCbCr
	#else
		stHDMI_Ctrl.pxdw = 12; //RGB888
	#endif

	tccfb_output_starter(TCC_OUTPUT_HDMI, lcdc_num, &stHDMI_Timing, &stHDMI_Ctrl,  0);

    return 1;
}

int tcc_hdmi_set_video_mode(char lcdc_num, struct HDMIVideoParameter *hdmi_video_mode)
{
	enum PixelLimit pxl_lmt = HDMI_FULL_RANGE;
    struct device_video_params device;

	DPRINTF("%s\n", __func__);

    // set phy
    if (!tcc_hdmi_set_phy_config(hdmi_video_mode))
    {
        DPRINTF("fail to config PHY!\n");
    }

    if (!hdmi_video_mode)
    {
        DPRINTF("bad args: hdmi_video_mode\n");
        return 0;
    }

    // parsing video parameters
	memcpy((void*)&device,(const void*)&(HDMIVideoParams[hdmi_video_mode->resolution]),sizeof(device));

	// set lcdc
	tcc_hdmi_set_lcdc_config(lcdc_num, hdmi_video_mode->resolution);
	
    // set pixel aspect ratio
    // !! must be setting before 'HDMI_IOC_SET_VIDEOMODE'
    hdmi_set_pixel_aspect_ratio(hdmi_video_mode->pixelAspectRatio);

    // set video parameters
#if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
	hdmi_set_video_mode(hdmi_video_mode);
#elif defined(CONFIG_TCC_HDMI_DRIVER_V1_3)
	hdmi_set_video_mode(device);
#endif

    // set color space
    if ( !hdmi_set_color_space(hdmi_video_mode->colorSpace) )
    {
        DPRINTF("bad args: hdmi_video_mode->colorSpace : Not Correct Arg = %d\n", hdmi_video_mode->colorSpace);
    }

    // set color depth
    if ( !hdmi_set_color_depth(hdmi_video_mode->colorDepth) )
    {
        DPRINTF("bad args: hdmi_video_mode->colorDepth : Not Correct Arg = %d\n", hdmi_video_mode->colorDepth);
    }

	// set pixel limitation.
	switch(hdmi_video_mode->colorSpace) 
	{
		case HDMI_CS_RGB:		/** RGB color space */
			if (hdmi_video_mode->resolution == v640x480p_60Hz)
				pxl_lmt = HDMI_FULL_RANGE;
			else
				pxl_lmt = HDMI_RGB_LIMIT_RANGE;
			break;

		case HDMI_CS_YCBCR444:	/** YCbCr 4:4:4 color space */
		case HDMI_CS_YCBCR422:	/** YCbCr 4:2:2 color space */
			pxl_lmt = HDMI_YCBCR_LIMIT_RANGE;
			break;
	}

    if (!hdmi_set_pixel_limit(pxl_lmt))
    {
		DPRINTF("bad args: hdmi_video_mode->colorDepth : Not Correct Arg = %d\n", pxl_lmt);
    }

    return 1;
}

static void tcc_hdmi_ddi_config_init (void)
{
	unsigned int regl;
	
	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl | HDMICTRL_HDMI_ENABLE, DDICFG_HDMICTRL);
	
	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl & ~HDMICTRL_RESET_TMDS, DDICFG_HDMICTRL);

	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl & ~HDMICTRL_RESET_SPDIF, DDICFG_HDMICTRL);

	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl & ~HDMICTRL_RESET_HDMI, DDICFG_HDMICTRL);
				
	// HDMI PHY Reset
	hdmi_phy_reset();

	// HDMI SPDIF Reset
	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl | HDMICTRL_RESET_SPDIF, DDICFG_HDMICTRL);	
	msleep(1);
	output_starter_writel(regl & ~HDMICTRL_RESET_SPDIF, DDICFG_HDMICTRL);

	// HDMI TMDS Reset
	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl | HDMICTRL_RESET_TMDS, DDICFG_HDMICTRL);
	msleep(1);
	output_starter_writel(regl & ~HDMICTRL_RESET_TMDS, DDICFG_HDMICTRL);

	// enable DDI_BUS HDMI CLK
	regl = output_starter_readl(DDICFG_HDMICTRL);
	output_starter_writel(regl | HDMICTRL_HDMI_ENABLE, DDICFG_HDMICTRL);
	msleep(1);
	
	// disable HDCP INT
	regl = output_starter_readb(HDMI_SS_INTC_CON);
	output_starter_writeb(regl & ~(1<<HDMI_IRQ_HDCP), HDMI_SS_INTC_CON);

	// disable SPDIF INT
	regl = output_starter_readb(HDMI_SS_INTC_CON);
	output_starter_writeb(regl & ~(1<<HDMI_IRQ_SPDIF), HDMI_SS_INTC_CON);
}

static int tcc_hdmi_set_hdmi_mode(int mode)
{
	int ret = 1;

	switch(mode)
	{
		case HDMI:
	        output_starter_writeb(HDMI_MODE_SEL_HDMI,HDMI_MODE_SEL);
	        output_starter_writeb(HDMICON2_HDMI,HDMI_CON_2);
			break;
		case DVI:
	        output_starter_writeb(HDMI_MODE_SEL_DVI,HDMI_MODE_SEL);
	        output_starter_writeb(HDMICON2_DVI,HDMI_CON_2);
			break;
		default:
			ret = 0;
			break;
	}

	return ret;
}

#endif	// HDMI NOT YET

void tcc_output_starter_setport(char lcdctrl_num, unsigned bit_per_pixel)
{
	int i;

	if(lcdctrl_num)	{
		tcc_gpio_config(TCC_GPE(0), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);		//LHSYNC
		tcc_gpio_config(TCC_GPE(1), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);		//LVSYNC
		tcc_gpio_config(TCC_GPE(26), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);	// LPXCLK
		tcc_gpio_config(TCC_GPE(27), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);	//LACBIAS
	}
	else {
		tcc_gpio_config(TCC_GPB(0), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);		// LPXCLK
		tcc_gpio_config(TCC_GPB(1), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);		//LHSYNC
		tcc_gpio_config(TCC_GPB(2), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);		//LVSYNC
		tcc_gpio_config(TCC_GPB(19), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);	//LACBIAS
	}

	switch (bit_per_pixel) {
		case 24:
			for(i = 18 ; i < 24; i++)	{
				if(lcdctrl_num)	{
					tcc_gpio_config(TCC_GPE(2 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
				else {
					tcc_gpio_config(TCC_GPB(3 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
			}

		case 18:
			for(i = 16 ; i < 18; i++)	{
				if(lcdctrl_num)	{
					tcc_gpio_config(TCC_GPE(2 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
				else {
					tcc_gpio_config(TCC_GPB(3 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
			}
			
		case 16:
			for(i = 8 ; i < 16; i++)	{
				if(lcdctrl_num)	{
					tcc_gpio_config(TCC_GPE(2 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
				else {
					tcc_gpio_config(TCC_GPB(3 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
			}
			
		case 8:
			for(i = 0 ; i < 8; i++)	{
				if(lcdctrl_num)	{
					tcc_gpio_config(TCC_GPE(2 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
				else {
					tcc_gpio_config(TCC_GPB(3 + i), GPIO_FN1|GPIO_OUTPUT|GPIO_LOW);
				}
			}
			break;
			
		default:
			// do nothing
			break;
	}
}

void tcc_output_starter_memclr(int img_width, int img_height)
{
	unsigned char *pBaseAddr;
	VIOC_RDMA *pRDMA = (VIOC_RDMA *)pOutput_Starter_RDMA;

	if(pmap_fb.base)
	{
		pBaseAddr = (unsigned char *)ioremap_nocache(pmap_fb.base, pmap_fb.size);
		if(pBaseAddr)
		{
			memset(pBaseAddr, 0x00, pmap_fb.size);

 			iounmap(pBaseAddr);
			pRDMA->nBASE0 = pmap_fb.base + (img_width*img_height*4);
		}
                // Force Code.!!
		pRDMA->nBASE0 = pmap_fb.base + (img_width*img_height*4);
		printk("%s fb_paddr=0x%08x fb_laddr=0x%08x\n", __func__, pmap_fb.base, (unsigned int)pBaseAddr);
	}

	if(pmap_attach.base)
	{
		pBaseAddr = (unsigned char *)ioremap_nocache(pmap_attach.base, pmap_attach.size/2);
		if(pBaseAddr)
		{
			memset(pBaseAddr, 0x00, pmap_attach.size/2);
 			iounmap(pBaseAddr);

			//pRDMA->nBASE0 = pmap_attach.base;
		}

		printk("%s attach_paddr=0x%08x attach_laddr=0x%08x\n", __func__, pmap_attach.base, (unsigned int)pBaseAddr);
	}
}

#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
void tcc_output_starter_hdmi(unsigned char lcdc_num, unsigned char hdmi_resolution, struct platform_device *pdev)
{
	unsigned int output_width, output_height;
	unsigned int image_width, image_height, image_fmt;
	unsigned int scaler_num;
	VIOC_DISP *pDISP;
	VIOC_WMIX *pWMIX;
	VIOC_RDMA *pRDMA;
	VIOC_SC *pSC;
	
	struct HDMIVideoParameter video;
	//struct HDMIVideoParameter audio;

	unsigned int clock_rate;
	struct clk *clock;
	struct device_node *np_parent = pdev->dev.of_node;
	struct device_node *np_child;
	
	printk("%s lcdc_num=%d hdmi_resolution=%d hdmi_mode=%d\n", __func__, Output_Starter_LCDC_Num, hdmi_resolution, tcc_display_data.hdmi_mode);
		
	if(hdmi_resolution >= STARTER_HDMI_MAX)
		hdmi_resolution = default_hdmi_resolution;

	video.resolution = TccSupportHdmiMode[hdmi_resolution];
	video.colorSpace = HDMI_CS_RGB;
	video.colorDepth = HDMI_CD_24;
	video.colorimetry = HDMI_COLORIMETRY_NO_DATA;
	video.pixelAspectRatio = HDMI_PIXEL_RATIO_16_9;
	
	if(tcc_display_data.hdmi_mode == 0)
		video.mode = HDMI;
	else
		video.mode = DVI;
		
	#if defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
		video.videoSrc = HDMI_SOURCE_EXTERNAL;
		video.hdmi_3d_format = HDMI_2D_VIDEO_FORMAT;
	#endif
	
	//gpio_set_value(TCC_GPB(25), 1);
	//udelay(100);
	
	pDISP = (VIOC_DISP *)pOutput_Starter_DISP;
	pWMIX =(VIOC_WMIX *)pOutput_Starter_WMIX; 
	pRDMA = (VIOC_RDMA *)pOutput_Starter_RDMA;

	pSC = (VIOC_SC *)pOutput_Starter_SCALER;
	
	if(Output_Starter_LCDC_Num)	
		VIOC_OUTCFG_SetOutConfig(VIOC_OUTCFG_HDMI, VIOC_OUTCFG_DISP1);
	else
		VIOC_OUTCFG_SetOutConfig(VIOC_OUTCFG_HDMI, VIOC_OUTCFG_DISP0);

	np_child = of_get_child_by_name(np_parent, "hdmi_starter");

	/* set and enable vioc clock */
	if(of_property_read_u32(np_child, "lcdc-clock-frequency", &clock_rate)) {
		printk("%s, Can't read clock-frequency\n", __func__);
		clock_rate = 32768;
	}

	if(Output_Starter_LCDC_Num)
		clock = of_clk_get_by_name(np_child, "lcdc1-clk");
	else
		clock = of_clk_get_by_name(np_child, "lcdc0-clk");

	clk_set_rate(clock, clock_rate);
	clk_prepare_enable(clock);
	
	/* enable hdmi-phy clock */
	clock = of_clk_get_by_name(np_child, "hdmi-phy");
	clk_prepare_enable(clock);
	
	/* set and enable hdmi-pclk */
	if(of_property_read_u32(np_child, "hdmi-clock-frequency", &clock_rate)) {
		printk("%s, Can't read clock-frequency\n", __func__);
		clock_rate = 27000000;
	}

	clock = of_clk_get_by_name(np_child, "hdmi-pclk");
    if (IS_ERR(clock)) {
            printk( "HDMI: failed to get hdmi pclk\n");
    }        
    printk("hdmi-pclk __clk_is_enabled=%d\r\n", __clk_is_enabled(clock));


	clk_set_rate(clock, clock_rate);
	clk_prepare_enable(clock);

	/* enable hdmi-hclk */
	clock = of_clk_get_by_name(np_child, "hdmi-hclk");
    if (IS_ERR(clock)) {
            printk( "HDMI: failed to get hdmi hclk\n");
    }        
    printk("hdmi-hclk __clk_is_enabled=%d\r\n", __clk_is_enabled(clock));

	clk_prepare_enable(clock);

    #if defined(CONFIG_ARCH_TCC896X) || defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
    {
        struct device_node *np_ipclk = of_find_compatible_node(NULL, NULL, "telechips,tcc897x-hdmi");                  
        if(np_ipclk != NULL) {
            clock = of_clk_get(np_ipclk, 2);
            if (IS_ERR(clock)) {
				printk( "HDMI: failed to get hdmi ipclk\n");
            } else {
				clk_prepare_enable(clock);
				clk_set_rate(clock, 50*1000*1000);
            }

        }
    }
    #endif
	#if defined(CONFIG_TCC_DISPLAY_HDMI_LVDS)
	tccfb_output_starter_set_attach(0);
	#endif
	VIOC_DISP_TurnOff(pDISP);
	VIOC_RDMA_SetImageDisable(pRDMA);

	#if defined(CONFIG_ARCH_TCC896X) || defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
	tcc_hdmi_set_phy_pwdn(1);
	#endif

	scaler_num = VIOC_SC2;

	if(VIOC_CONFIG_PlugOut(scaler_num) != VIOC_PATH_DISCONNECTED)
		printk("%s, error: scaler%d couldn't be plugged-out!!\n", __func__, scaler_num);
	else
		printk("%s, success: scaler%d was plugged-out!!\n", __func__, scaler_num);
		
	#if 0//def CONFIG_LCD_HDMI1920X1080
		image_width = 1920;
		image_height = 1080;
	#else
		image_width = 1280;
		image_height = 720;
	#endif
	image_fmt = TCC_LCDC_IMG_FMT_RGB565;
	
	tcc_output_starter_memclr(image_width, image_height);

	output_width = LCDCTimimgParams[video.resolution].lpc + 1;
	output_height = LCDCTimimgParams[video.resolution].flc + 1;

	tcc_hdmi_ddi_config_init();
	tcc_hdmi_set_video_mode(Output_Starter_LCDC_Num, &video);
	tcc_hdmi_set_hdmi_mode(video.mode);
	
	VIOC_SC_SetBypass(pSC, OFF);
	VIOC_SC_SetSrcSize(pSC, image_width, image_height);			// set source size in scaler
	VIOC_SC_SetDstSize(pSC, output_width, output_height);		// set destination size in scaler
	VIOC_SC_SetOutSize(pSC, output_width, output_height);		// set output size in scaer
	VIOC_SC_SetUpdate(pSC);										// update scaler

	VIOC_RDMA_SetImageSize(pRDMA, image_width, image_height);	// set image size
	VIOC_RDMA_SetImageFormat(pRDMA, image_fmt);					// set image format
	VIOC_RDMA_SetImageIntl(pRDMA, false);						// set image interlace mode
	VIOC_RDMA_SetImageOffset(pRDMA, image_fmt, image_width);	// set image offset

	VIOC_RDMA_SetImageAlphaSelect(pRDMA, 1);					// set alpha setting
	VIOC_RDMA_SetImageAlphaEnable(pRDMA, 1);					// set chroma key color setting

	VIOC_RDMA_SetImageEnable(pRDMA);
	//BITCSET(pRDMA->uCTRL.nREG, HwDMA_IEN, HwDMA_IEN);
	
	VIOC_WMIX_SetPosition(pWMIX, 0, 0, 0);
	VIOC_WMIX_SetChromaKey(pWMIX, 0, 0, 0, 0, 0, 0xF8, 0xFC, 0xF8);
	VIOC_WMIX_SetUpdate(pWMIX);

	VIOC_DISP_TurnOn(pDISP);

	//if (video.mode == HDMI)
	//	hdmi_set_audio_mode(&audio);

	hdmi_start();

	#if defined(CONFIG_TCC_DISPLAY_HDMI_LVDS)
	tccfb_output_starter_set_attach(1);
	#endif

}
#endif

void tcc_output_starter_composite(unsigned char lcdc_num, unsigned char type, struct platform_device *pdev)
{
#ifdef CONFIG_FB_TCC_COMPOSITE
	COMPOSITE_SPEC_TYPE spec;
	unsigned int image_width, image_height, image_fmt;

	stLTIMING				CompositeTiming;
	stLCDCTR				LcdCtrlParam;
	PVIOC_DISP				pDISP ;
	PVIOC_WMIX				pWMIX ;
	PVIOC_RDMA				pRDMA;
	VIOC_SC 				*pSC;
 	PDDICONFIG 				pDDICfg = pOutput_Starter_DDICFG;
	PNTSCPAL 				pTVE = pOutput_Starter_TVE;
	PNTSCPAL_ENCODER_CTRL 	pTVE_VEN = pOutput_Starter_TVE_VEN;

	unsigned int clock_rate;
	struct clk *clock;
	struct device_node *np_parent = pdev->dev.of_node;
	struct device_node *np_child;
	
	printk("%s, lcdc_num=%d, type=%d\n", __func__, Output_Starter_LCDC_Num, type);

	if(type >= STARTER_COMPOSITE_MAX)
		type = default_composite_resolution;

	if(type == STARTER_COMPOSITE_NTSC)
		tcc_composite_get_spec(NTSC_M, &spec);
	else
		tcc_composite_get_spec(PAL_B, &spec);
	
	BITSET(pDDICfg->PWDN.nREG, Hw1);		// PWDN - TVE
	BITCLR(pDDICfg->SWRESET.nREG, Hw1);		// SWRESET - TVE
	BITSET(pDDICfg->SWRESET.nREG, Hw1);		// SWRESET - TVE	
	BITSET(pDDICfg->NTSCPAL_EN.nREG, Hw0);	// NTSCPAL_EN	

	pDISP = (VIOC_DISP *)pOutput_Starter_DISP;
	pWMIX = (VIOC_WMIX *)pOutput_Starter_WMIX;
	pRDMA = (VIOC_RDMA *)pOutput_Starter_RDMA;
		
	if(Output_Starter_LCDC_Num)	
		VIOC_OUTCFG_SetOutConfig(VIOC_OUTCFG_SDVENC, VIOC_OUTCFG_DISP1);
	else
		VIOC_OUTCFG_SetOutConfig(VIOC_OUTCFG_SDVENC, VIOC_OUTCFG_DISP0);

	//tca_ckc_setippwdn(PMU_ISOL_VDAC, 0);

	pSC = (VIOC_SC *)pOutput_Starter_SCALER;

	np_child = of_get_child_by_name(np_parent, "composite_starter");

	/* set and enable vioc clock */
	if(of_property_read_u32(np_child, "lcdc-clock-frequency", &clock_rate)) {
		printk("%s, Can't read clock-frequency\n", __func__);
		clock_rate = 27000000;
	}

	if(Output_Starter_LCDC_Num)
		clock = of_clk_get_by_name(np_child, "lcdc1-clk");
	else
		clock = of_clk_get_by_name(np_child, "lcdc0-clk");

	clk_set_rate(clock, clock_rate);
	clk_prepare_enable(clock);

	/*
	clock = clk_get(0, "vdac_phy");
	clk_enable(clock);

	clock = clk_get(0, "ntscpal");
	clk_enable(clock);
	*/

	VIOC_DISP_TurnOff(pDISP);
	VIOC_RDMA_SetImageDisable(pRDMA);
	
	#if 0//def CONFIG_LCD_HDMI1920X1080
		image_width = 1920;
		image_height = 1080;
	#else
		image_width = 1280;
		image_height = 720;
	#endif

	image_fmt = TCC_LCDC_IMG_FMT_RGB565;
	
	tcc_output_starter_memclr(image_width, image_height);

	CompositeTiming.lpw = spec.composite_LPW;
	CompositeTiming.lpc = spec.composite_LPC + 1;
	CompositeTiming.lswc = spec.composite_LSWC + 1;
	CompositeTiming.lewc = spec.composite_LEWC + 1;
	
	CompositeTiming.vdb = spec.composite_VDB;
	CompositeTiming.vdf = spec.composite_VDF;
	CompositeTiming.fpw = spec.composite_FPW1;
	CompositeTiming.flc = spec.composite_FLC1;
	CompositeTiming.fswc = spec.composite_FSWC1;
	CompositeTiming.fewc = spec.composite_FEWC1;
	CompositeTiming.fpw2 = spec.composite_FPW2;
	CompositeTiming.flc2 = spec.composite_FLC2;
	CompositeTiming.fswc2 = spec.composite_FSWC2;
	CompositeTiming.fewc2 = spec.composite_FEWC2;
	
	memset((stLCDCTR *)&LcdCtrlParam, 0x00, sizeof(stLCDCTR));
	LcdCtrlParam.r2ymd = 3;
	LcdCtrlParam.ckg = 1;
	LcdCtrlParam.id= 0;
	LcdCtrlParam.iv = 0;
	LcdCtrlParam.ih = 1;
	LcdCtrlParam.ip = 1;
	LcdCtrlParam.clen = 1;
	LcdCtrlParam.r2y = 1;
	LcdCtrlParam.pxdw = 6;
	LcdCtrlParam.dp = 0;
	LcdCtrlParam.ni = 0;
	LcdCtrlParam.tv = 1;
	#ifdef CONFIG_ARCH_TCC898X
	LcdCtrlParam.advi = 0;		// 0 is enable (only tcc898x)
	#else
	LcdCtrlParam.advi = 1;		// 1 is enable
	#endif

	tccfb_output_starter(TCC_OUTPUT_COMPOSITE, Output_Starter_LCDC_Num, &CompositeTiming, &LcdCtrlParam, 0);

 	//Disconnect LCDC with NTSC/PAL encoder
	BITCLR(pTVE_VEN->VENCON.nREG, HwTVEVENCON_EN_EN);
		
	//Set ECMDA Register
	if(type == STARTER_COMPOSITE_NTSC)
	{
		pTVE->ECMDA.nREG  = 
			HwTVECMDA_PWDENC_PD 			|	// [7]	 Power down mode for entire digital logic of TV encoder
			HwTVECMDA_FDRST_1				|	// [6]	 Chroma is free running as compared to H-sync
			HwTVECMDA_FSCSEL_NTSC			|	// [5:4] Color subcarrier frequency is 3.57954545 MHz for NTSC
			HwTVECMDA_PEDESTAL				|	// [3]	 Video Output has a pedestal (0 is NTSC-J)
			HwTVECMDA_PIXEL_601 			|	// [2]	 Input data is at 601 rates.
			HwTVECMDA_IFMT_525				|	// [1]	 Output data has 525 lines
			HwTVECMDA_PHALT_NTSC			|	// [0]	 NTSC encoded chroma signal output
			0;
	}
	else
	{
		pTVE->ECMDA.nREG  = 
			HwTVECMDA_FDRST_1				|	// [6]	 Chroma is free running as compared to H-sync
			HwTVECMDA_FSCSEL_PALX			|	// [5:4] Color subcarrier frequency is 4.43361875 MHz for PAL-B,D,G,H,I,N
			HwTVECMDA_PIXEL_601 			|	// [2]	 Input data is at 601 rates.
			HwTVECMDA_IFMT_625				|	// [1]	 Output data has 625 lines
			HwTVECMDA_PHALT_PAL 			|	// [0]	 PAL encoded chroma signal output
			0;
	}
	
	//Set DACSEL Register
	BITSET(pTVE->DACSEL.nREG, HwTVEDACSEL_DACSEL_CVBS);
	//Set DACPD Register
	BITCLR(pTVE->DACPD.nREG, HwTVEDACPD_PD_EN);

	BITSET(pTVE->ICNTL.nREG, HwTVEICNTL_VSIP_HIGH);
	BITSET(pTVE->ICNTL.nREG, HwTVEICNTL_HSVSP_RISING);
	#if 0 // COMPOSITE_CCIR656
	BITCSET(pTVE->ICNTL.nREG, HwTVEICNTL_ISYNC_MASK, HwTVEICNTL_ISYNC_ESAV_F);
	#else
	BITCSET(pTVE->ICNTL.nREG, HwTVEICNTL_ISYNC_MASK, HwTVEICNTL_ISYNC_HVSI);
	#endif
		
	//Set the Vertical Offset
	BITCSET(pTVE->HVOFFST.nREG, 0x07, ((0 & 0x700)>>8));
	pTVE->HOFFST.nREG = (0 & 0xFF);
			
	//Set the Horizontal Offset
	BITCSET(pTVE->HVOFFST.nREG, 0x08, ((1 & 0x100)>>5));
	pTVE->VOFFST.nREG = (1 & 0xFF);
			
	//Set the Digital Output Format
	BITCSET(pTVE->HVOFFST.nREG, HwTVEHVOFFST_INSEL_MASK, HwTVEHVOFFST_INSEL(2));
			
	//Set HSVSO Register
	BITCSET(pTVE->HSVSO.nREG, 0x07, ((0 & 0x700)>>8));
	pTVE->HSOE.nREG = (0 & 0xFF);
	BITCSET(pTVE->HSVSO.nREG, 0x38, ((0 & 0x700)>>5));
	pTVE->HSOB.nREG = (0 & 0xFF);
	BITCSET(pTVE->HSVSO.nREG, 0x40, ((0 & 0x100)>>2));
	pTVE->VSOB.nREG = (0 & 0xFF);

	//Set VSOE Register
	BITCSET(pTVE->VSOE.nREG, 0x1F, (0 & 0x1F));
	BITCSET(pTVE->VSOE.nREG, 0xC0, (0 & 0x03)<<6);
	BITCSET(pTVE->VSOE.nREG, 0x20, (0 & 0x01)<<5);
			
	//Set the Connection Type
	BITSET(pTVE_VEN->VENCIF.nREG, HwTVEVENCIF_FMT_1);

	BITSET(pTVE_VEN->VENCON.nREG, HwTVEVENCON_EN_EN);
	BITSET(pTVE->DACPD.nREG, HwTVEDACPD_PD_EN);
	BITCLR(pTVE->ECMDA.nREG, HwTVECMDA_PWDENC_PD);

	VIOC_DISP_TurnOn(pDISP);
#endif
}

void tcc_output_starter_component(unsigned char lcdc_num, unsigned char type, struct platform_device *pdev)
{
#ifdef CONFIG_FB_TCC_COMPONENT
	int mode;

	COMPONENT_SPEC_TYPE component_spec;
	stLTIMING ComponentTiming;
	stLCDCTR LcdCtrlParam;

	PVIOC_DISP		pDISP;
	PVIOC_WMIX		pWMIX;
	PVIOC_RDMA		pRDMA;
	PVIOC_SC		pSC;

	unsigned int clock_rate;
	struct clk *clock;
	struct device_node *np_parent = pdev->dev.of_node;
	struct device_node *np_child;

	unsigned int align_swap = 0;
	
	printk("%s, lcdc_num=%d, type=%d\n", __func__, Output_Starter_LCDC_Num, type);

	if(type >= STARTER_COMPONENT_MAX)
		type = default_component_resolution;

	switch (type) {
	case STARTER_COMPONENT_1080I:
		mode = COMPONENT_MODE_1080I;
		break;
	case STARTER_COMPONENT_720P:
	default:
		mode = COMPONENT_MODE_720P;
		break;
	}
	tcc_component_get_spec(mode, &component_spec);

	//LCDC_IO_Set(lcdc_num, component_spec.component_bus_width);

	pDISP = (VIOC_DISP *)pOutput_Starter_DISP;
	pWMIX = (VIOC_WMIX *)pOutput_Starter_WMIX;
	pRDMA = (VIOC_RDMA *)pOutput_Starter_RDMA;
	pSC = (VIOC_SC *)pOutput_Starter_SCALER;
	DPRINTF("%s: RDMA(%p)-SC(%p)-WMIX(%p)-DISP(%p)\n", __func__, pRDMA, pSC, pWMIX, pDISP);

	np_child = of_get_child_by_name(np_parent, "component_starter");

	/* set and enable vioc clock */
	if (of_property_read_u32(np_child, "lcdc-clock-frequency", &clock_rate)) {
		printk("%s, Can't read clock-frequency\n", __func__);
		clock_rate = 74250000;
	}

	if(Output_Starter_LCDC_Num)
		clock = of_clk_get_by_name(np_child, "lcdc1-clk");
	else
		clock = of_clk_get_by_name(np_child, "lcdc0-clk");

	clk_set_rate(clock, clock_rate);
	clk_prepare_enable(clock);

	VIOC_DISP_TurnOff(pDISP);
	VIOC_RDMA_SetImageDisable(pRDMA);

	{
	unsigned int image_width, image_height;
	#if 0 //def CONFIG_LCD_HDMI1920X1080
	image_width = 1920;
	image_height = 1080;
	#else
	image_width = 1280;
	image_height = 720;
	#endif
	tcc_output_starter_memclr(image_width, image_height);
	}

	ComponentTiming.lpw = component_spec.component_LPW;
	ComponentTiming.lpc = component_spec.component_LPC + 1;
	ComponentTiming.lswc = component_spec.component_LSWC + 1;
	ComponentTiming.lewc = component_spec.component_LEWC + 1;
	ComponentTiming.vdb = component_spec.component_VDB;
	ComponentTiming.vdf = component_spec.component_VDF;
	ComponentTiming.fpw = component_spec.component_FPW1;
	ComponentTiming.flc = component_spec.component_FLC1;
	ComponentTiming.fswc = component_spec.component_FSWC1;
	ComponentTiming.fewc = component_spec.component_FEWC1;
	ComponentTiming.fpw2 = component_spec.component_FPW2;
	ComponentTiming.flc2 = component_spec.component_FLC2;
	ComponentTiming.fswc2 = component_spec.component_FSWC2;
	ComponentTiming.fewc2 = component_spec.component_FEWC2;

	memset((stLCDCTR *)&LcdCtrlParam, 0x00, sizeof(stLCDCTR));

	switch(type)
	{
		case STARTER_COMPONENT_480I_NTSC:
		case STARTER_COMPONENT_576I_PAL:
			break;

		case STARTER_COMPONENT_720P:
			LcdCtrlParam.r2ymd = 3;
			LcdCtrlParam.ckg = 1;
			LcdCtrlParam.id= 0;
			LcdCtrlParam.iv = 1;
			LcdCtrlParam.ih = 1;
			LcdCtrlParam.ip = 0;
			LcdCtrlParam.pxdw = 12;
			LcdCtrlParam.ni = 1;
			break;

		case STARTER_COMPONENT_1080I:
			LcdCtrlParam.r2ymd = 3;
			LcdCtrlParam.ckg = 1;
			LcdCtrlParam.id= 0;
			LcdCtrlParam.iv = 0;
			LcdCtrlParam.ih = 1;
			LcdCtrlParam.ip = 1;
			LcdCtrlParam.pxdw = 12;
			LcdCtrlParam.ni = 0;
			LcdCtrlParam.tv = 1;
			#ifdef CONFIG_ARCH_TCC898X
			LcdCtrlParam.advi = 0;		// 0 is enable (only tcc898x)
			#else
			LcdCtrlParam.advi = 1;		// 1 is enable
			#endif
			break;
		default:
			break;
	}

	#if defined(CONFIG_FB_TCC_COMPONENT_ADV7343)
	switch (ADV7343_DEFAULT_OUTPUT_FORMAT) {
	case OUTPUT_FORMAT_RGB888:
		LcdCtrlParam.r2y = 0;
		LcdCtrlParam.pxdw = 12;	// 24bit RGB888
		break;
	case OUTPUT_FORMAT_YCbCr_24bit:
		LcdCtrlParam.r2ymd = 3;
		LcdCtrlParam.r2y = 1;
		LcdCtrlParam.pxdw = 12;	// 24bit RGB888 with r2y enable = 24bit (fake) YCbCr
		//dctrl_swap = 0x0; //0x4;
		align_swap = 0x4; //0x0;
		break;
	case OUTPUT_FORMAT_YCbCr_16bit:
	default:
		LcdCtrlParam.r2ymd = 3;
		LcdCtrlParam.r2y = 1;
		LcdCtrlParam.pxdw = 8;	// 16bit YCbCr
		break;
	}
	/* set VE_PBLK(GPIO_B19) and id=active high */
	LcdCtrlParam.id = 0;
	#endif

	tccfb_output_starter(TCC_OUTPUT_COMPONENT, Output_Starter_LCDC_Num, &ComponentTiming, &LcdCtrlParam, 0);

	#ifndef CONFIG_ARCH_TCC898X
	tcc_gpio_config(TCC_GPE(27), GPIO_FN0|GPIO_OUTPUT|GPIO_HIGH);	// VE_FIELD: GPIO_E27
	#endif

	#if defined(CONFIG_FB_TCC_COMPONENT_ADV7343)
	VIOC_DISP_SetSwapbf(pDISP, align_swap);	// overwrite swap reg. after tccfb_output_starter()
	adv7343_enable(mode, ADV7343_DEFAULT_OUTPUT_FORMAT, 1);
	#elif defined(CONFIG_FB_TCC_COMPONENT_THS8200)
	ths8200_enable(mode, 1);
	#endif

	#if 0 // for debugging
	{
		unsigned int i;
		unsigned int *pReg = (unsigned int *)pLCDC_CH;
		for(i=0; i<32; i++)
		{
			printk("0x%08x: 0x%08x\n", pReg+i, *(pReg+i));
		}
	}
	#endif

	VIOC_DISP_TurnOn(pDISP);
#endif
}

#ifdef CONFIG_OF
static int tcc_output_starter_parse_dt(struct device_node *np)
{
	struct device_node *np_fb_child, *np_fb, *np_fb_1st, *np_fb_2nd, *np_hpd;
	int index = 0, ret = 0;

	/* get the information of output_starter device node*/
	np_fb_child = of_parse_phandle(np, "scaler", 0);
	if(np_fb_child) {
		of_property_read_u32_index(np, "scaler", 1, &index);
		pOutput_Starter_SCALER = (PVIOC_SC)of_iomap(np_fb_child, index);
	} else {
		printk("%s, could not find scaler node\n", __func__);
		ret = -ENODEV;
	}

	np_fb_child = of_parse_phandle(np, "ddicfg", 0);
	if(np_fb_child) {
		pOutput_Starter_DDICFG = (PDDICONFIG)of_iomap(np_fb_child, 0);
	} else {
		printk("%s, could not find ddi_config node\n", __func__);
		ret = -ENODEV;
	}

	np_fb_child = of_parse_phandle(np, "tve", 0);
	if(np_fb_child) {
		pOutput_Starter_TVE = (PNTSCPAL)of_iomap(np_fb_child, 0);
		pOutput_Starter_TVE_VEN = (PNTSCPAL_ENCODER_CTRL)of_iomap(np_fb_child, 1);
	} else {
		printk("%s, could not find scaler node\n", __func__);
		ret = -ENODEV;
	}

	/* get the information of vioc-fb device node*/
	np_fb = of_find_compatible_node(NULL, NULL, "telechips,vioc-fb");

	if(of_property_read_u32(np_fb, "telechips,fbdisplay_num", &Output_Starter_LCDC_Num)) {
		pr_err("%s, could not find fbdisplay_num\n", __func__);
		ret = -ENODEV;
	}

	Output_Starter_LCDC_Num = daudio_lcd_type_lvds_check();

	if(Output_Starter_LCDC_Num) {
		np_fb_1st = of_find_node_by_name(np_fb, "fbdisplay1");
		np_fb_2nd = of_find_node_by_name(np_fb, "fbdisplay0");
	}
	else {
		np_fb_1st = of_find_node_by_name(np_fb, "fbdisplay0");
		np_fb_2nd = of_find_node_by_name(np_fb, "fbdisplay1");
	}

	np_fb_child = of_parse_phandle(np_fb_1st,"telechips,disp", 0);
	if(np_fb_child) {
		pOutput_Starter_DISP = (VIOC_DISP *)of_iomap(np_fb_child, 0);
	} else {
		pr_err( "%s, could not find disp node\n", __func__);
		ret = -ENODEV;
	}

	np_fb_child = of_parse_phandle(np_fb_1st,"telechips,wmixer", 0);
	if(np_fb_child) {
		pOutput_Starter_WMIX = (VIOC_WMIX *)of_iomap(np_fb_child, 0);
	} else {
		pr_err( "%s, could not find wmixer node\n", __func__);
		ret = -ENODEV;
	}

	np_fb_child = of_parse_phandle(np_fb_1st,"telechips,rdma", 0);
	if(np_fb_child) {
		of_property_read_u32_index(np_fb_1st, "telechips,rdma", 1+0, &index);
		pOutput_Starter_RDMA = (VIOC_RDMA *)of_iomap(np_fb_child, index);
	} else {
		pr_err( "%s, could not find rdma node\n", __func__);
		ret = -ENODEV;
	}

	/* get the information of hpd node*/
	#if defined(CONFIG_ARCH_TCC893X)
		np_hpd = of_find_compatible_node(NULL, NULL, "telechips,tcc893x-hdmi-hpd");
	#elif defined(CONFIG_ARCH_TCC896X)
		np_hpd = of_find_compatible_node(NULL, NULL, "telechips,tcc896x-hdmi-hpd");
	#elif defined(CONFIG_ARCH_TCC897X) || defined(CONFIG_ARCH_TCC570X)
		np_hpd = of_find_compatible_node(NULL, NULL, "telechips,tcc897x-hdmi-hpd");
        #elif defined(CONFIG_ARCH_TCC898X)
                np_hpd = of_find_compatible_node(NULL, NULL, "telechips,dw-hdmi-tx");
	#endif
	if(np_hpd) {
		hdmi_hpd_port = of_get_gpio(np_hpd, 0);
		if(gpio_is_valid(hdmi_hpd_port)) 
		{
			printk("%s, hpd port: 0x%02x\n", __func__, hdmi_hpd_port);
			#if !defined(CONFIG_ARCH_TCC898X)
			gpio_request(hdmi_hpd_port, "component-hdmi-hpd");
			gpio_direction_input(hdmi_hpd_port);
			#endif
		}
		else
		{
			printk("%s, err to get hpd port\n", __func__);
			hdmi_hpd_port = -1;
		}
	} else {
		printk( "%s, could not find hpd node\n", __func__);
		ret = -ENODEV;
	}

	printk("%s, Output_Starter_LCDC_Num = %d \n", __func__, Output_Starter_LCDC_Num);

	return ret;
}
#else
static int tcc_output_starter_parse_dt(struct device_node *np)
{
}
#endif

static int tcc_output_starter_probe(struct platform_device *pdev)
{
	int hdmi_detect = 0;
	unsigned char lcdc_1st = STARTER_LCDC_0;
	unsigned char lcdc_2nd = STARTER_LCDC_1;

    printk("\r\n\r\ntcc_output_starter_probe\r\n\r\n");

	tcc_output_starter_parse_dt(pdev->dev.of_node);

	#if defined(CONFIG_ARCH_TCC893X)        
	i2c_add_driver(&tcc_hdmi_phy_i2c_driver);
	#endif

	#if defined(CONFIG_OUTPUT_SKIP_KERNEL_LOGO)
	if (!strncmp(boot_recovery_mode, "boot_recovery", 13)) {
		printk("%s, boot mode is recovery mode\n", __func__);
	} else {
		printk("%s, skip displaying kernel logo\n", __func__);
		return 0;
	}
	#endif

	//if(tcc_display_data.output >= STARTER_OUTPUT_MAX)
	{
		tcc_display_data.hdmi_resolution = default_hdmi_resolution;
		tcc_display_data.composite_resolution = default_composite_resolution;
		tcc_display_data.component_resolution = default_component_resolution;
	}

	printk("%s, output_setting=%d, hdmi_resolution=%d, composite_resolution=%d, component_resolution=%d\n", __func__, 
			tcc_display_data.output, tcc_display_data.hdmi_resolution, tcc_display_data.composite_resolution, tcc_display_data.component_resolution);

	pmap_get_info("fb_video", &pmap_fb);
	pmap_get_info("output_attach", &pmap_attach);

	if(Output_Starter_LCDC_Num) { 
		lcdc_1st = STARTER_LCDC_1; /* LCDC0: HDMI/Component/CVBS */
		lcdc_2nd = STARTER_LCDC_0; /* LCDC1: Attached CVBS */
	}
	else {
		lcdc_1st = STARTER_LCDC_0; /* LCDC0: HDMI/Component/CVBS */
		lcdc_2nd = STARTER_LCDC_1; /* LCDC1: Attached CVBS */
	}

	#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4) || defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
	hdmi_detect = tcc_hdmi_detect_cable();
	#endif

	/*
	 * Extend-display Output Setting
	 * -----------------------------
	 * #if defined(CONFIG_TCC_DISPLAY_MODE_AUTO_DETECT)
	 *     #define TCC_OUTPUT_STARTER_AUTO_HDMI_CVBS
	 * #elif defined(CONFIG_TCC_DISPLAY_MODE_DUAL_HDMI_CVBS)
	 *     #define TCC_OUTPUT_STARTER_ATTACH_HDMI_CVBS
	 * #elif defined(CONFIG_TCC_DISPLAY_MODE_DUAL_AUTO)
	 *     #define TCC_OUTPUT_STARTER_ATTACH_DUAL_AUTO
	 * #else
	 *     #if defined(CONFIG_STB_BOARD_STB1)
	 *         #define TCC_OUTPUT_STARTER_ATTACH_DUAL_AUTO
	 *     #else
	 *         #define TCC_OUTPUT_STARTER_NORMAL
	 *     #endif
	 * #endif 
	 */
#if defined(TCC_OUTPUT_STARTER_AUTO_HDMI_CVBS)

	if (hdmi_detect == true) {
		DPRINTF("AUTO_HDMI_CVBS: hdmi\n");
		#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
		tcc_output_starter_hdmi(lcdc_1st, default_hdmi_resolution, pdev);
		#elif defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
		tcc_output_starter_hdmi_v2_0(HDMI_VIDEO_MODE_VIC, HDMI_VIDEO_MODE_HZ, 0, lcdc_1st,
				pOutput_Starter_RDMA, pOutput_Starter_SCALER, pOutput_Starter_WMIX, pOutput_Starter_DISP,
				VIOC_SC2, HDMI_IMG_WIDTH, HDMI_IMG_HEIGHT, HDMI_IMG_FMT);
		#endif
	} else {
		DPRINTF("AUTO_HDMI_CVBS: composite\n");
		tcc_output_starter_composite(lcdc_1st, default_composite_resolution, pdev);
	}

#elif defined(TCC_OUTPUT_STARTER_ATTACH_HDMI_CVBS)

	/*
	 * 1st output - HDMI
	 */
	DPRINTF("ATTACH_HDMI_CVBS: hdmi\n");
	#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
	tcc_output_starter_hdmi(lcdc_1st, default_hdmi_resolution, pdev);
	#elif defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
	tcc_output_starter_hdmi_v2_0(HDMI_VIDEO_MODE_VIC, HDMI_VIDEO_MODE_HZ, 0, lcdc_1st,
			pOutput_Starter_RDMA, pOutput_Starter_SCALER, pOutput_Starter_WMIX, pOutput_Starter_DISP,
			VIOC_SC2, HDMI_IMG_WIDTH, HDMI_IMG_HEIGHT, HDMI_IMG_FMT);
	#endif

	/*
	 * 2nd output - CVBS
	 */
	DPRINTF("ATTACH_HDMI_CVBS: composite\n");
	tcc_composite_attach(lcdc_2nd, default_composite_resolution, 1);

#elif defined(TCC_OUTPUT_STARTER_ATTACH_DUAL_AUTO)

	/*
	 * 1st output - HDMI or Component
	 */
	if (hdmi_detect == true) {
		DPRINTF("ATTACH_DUAL_AUTO: hdmi\n");
		#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
		tcc_output_starter_hdmi(lcdc_1st, default_hdmi_resolution, pdev);
		#elif defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
		tcc_output_starter_hdmi_v2_0(HDMI_VIDEO_MODE_VIC, HDMI_VIDEO_MODE_HZ, 0, lcdc_1st,
				pOutput_Starter_RDMA, pOutput_Starter_SCALER, pOutput_Starter_WMIX, pOutput_Starter_DISP,
				VIOC_SC2, HDMI_IMG_WIDTH, HDMI_IMG_HEIGHT, HDMI_IMG_FMT);
		#endif
	} else {
		DPRINTF("ATTACH_DUAL_AUTO: component\n");
		tcc_output_starter_component(lcdc_1st, default_component_resolution, pdev);
	}

	/*
	 * 2nd output - CVBS
	 */
	DPRINTF("ATTACH_DUAL_AUTO: composite\n");
	tcc_composite_attach(lcdc_2nd, default_composite_resolution, 1);

#else

	/*
	 * TCC_OUTPUT_STARTER_NORMAL - HDMI
	 */
	DPRINTF("OUTPUT_STARTER_NORMAL: hdmi\n");
	#if defined(CONFIG_TCC_HDMI_DRIVER_V1_3) || defined(CONFIG_TCC_HDMI_DRIVER_V1_4)
	tcc_output_starter_hdmi(lcdc_1st, default_hdmi_resolution, pdev);
	#elif defined(CONFIG_TCC_HDMI_DRIVER_V2_0)
	tcc_output_starter_hdmi_v2_0(HDMI_VIDEO_MODE_VIC, HDMI_VIDEO_MODE_HZ, 0, lcdc_1st,
			pOutput_Starter_RDMA, pOutput_Starter_SCALER, pOutput_Starter_WMIX, pOutput_Starter_DISP,
			VIOC_SC2, HDMI_IMG_WIDTH, HDMI_IMG_HEIGHT, HDMI_IMG_FMT);
	#endif

#endif

	return 0;
}

static int tcc_output_starter_remove(struct platform_device *pdev)
{
	i2c_del_driver(&tcc_hdmi_phy_i2c_driver);

	return 0;
}

#ifdef CONFIG_OF
static struct of_device_id output_starter_of_match[] = {
	{ .compatible = "telechips,tcc-output-starter" },
	{}
};
MODULE_DEVICE_TABLE(of, output_starter_of_match);
#endif

static struct platform_driver tcc_output_starter_driver = {
	.probe	= tcc_output_starter_probe,
	.remove	= tcc_output_starter_remove,
	.driver	= {
		.name	= "tcc_output_starter",
		.owner	= THIS_MODULE,
		.of_match_table = of_match_ptr(output_starter_of_match),
	},
};

int __init tcc_output_starter_init(void)
{
	return platform_driver_register(&tcc_output_starter_driver);
}

static __exit void tcc_output_starter_exit(void)
{
	platform_driver_unregister(&tcc_output_starter_driver);
}

MODULE_AUTHOR("TELECHIPS");
MODULE_LICENSE("GPL");

late_initcall(tcc_output_starter_init);
module_exit(tcc_output_starter_exit);
